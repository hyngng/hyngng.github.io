---
title:  "자료구조"

categories:
  - 프로그래밍
tags:
  - [자료구조]

toc: true
toc_sticky: true
 
date: 2023-03-14
last_modified_at: 2023-03-14
---

<br>

# 아직 작성중인 글

<br>

- 데이터 : 현실세계에서 관측되는 값 또는 사실

<br>

- 데이터의 표현 단위
    - bit  : 정보표현의 최소단위
    - byte : 8비트 → 맨 앞과 맨 뒤 이름
      - ASCII CODE : 중형 PC에서의 데이터 통신용
        - 약자 :
        - 7bit 데이터 사용 : 숫자(10), 문자(52), 특수문자(30)개를 모두 표현하기 위해 2^7(=128)의 가짓수만 필요하기 때문
      - EBCICD : 대형 PC or IBM 기종에서의 데이터 통신용
        - 약자 :
        - 8bit 데이터 사용
      - UNICODE : 한글, 그리스 알파벳, 히라가나&가타가나, 한자, 키릴 문자, 만주 문자 등의 전세계 문자가 할당됨
        - 16bit 데이터 사용 : 2^16 = 65536, 24자 한글로만 11172가짓수 조합이 가능하고, 약 30000만여개의 실용한자가 존재하기 때문
    - field(= item) : 연관된 문자의 모임
      - 예를 들어, 행렬 데이터는 여러개의 필드로 구성된다.
    - record : 연관된 항목의 모임
      - 예를 들어, 행렬 데이터 중 행 하나하나는 관점에 따라 레코드로 볼 수 있다.
    - file : 연관된 record의 모임 or 보조기억장치의 연속적인 영역이 존재하는 문자열의 모임으로서 논리적인 한 단위로 취급되는 것 
      - 예를 들어, 행렬 데이터 자체를 레코드의 모임으로서 하나의 파일로 볼 수 있다.
    - Data Base : 연관된 파일의 모임

    데이터 통신업계의 코드 : 표준 코드 (아스키, 유니...)

    정수와 실수 등이 컴퓨터 내에서 어떻게 표현되는지

<br>

  - 컴퓨터의 소수 표현
  
    십진법 실수를 이진법으로 표현하기 -> 이론상 0.75 = 0.5(= 2^-1) + 0.25(= 2^-2)로 표현되므로, 0.75는 이진법으로 나타내면 '0.11'
    -> 이 경우 0.3 등은 0.11111....로 무한히 이어져야 함

    - 고정소수점
      - 정수 표현 비트수와 소수 표현 비트수를 할당
    - 부동소수점
      - 


<!--메모-->
2진정수 - 2's complement(보수)가 가장 많이 쓰임(signed magnitude, 1's complement 등)
  -> 부호와절대값(signed magnitude)
    -> 양수표현방법 : 8비트 중 가장 앞자리(=sign) 값이 0이면 양수, 1이면 음수.
      -> 표현할 수 있는 정수의 범위가 할당되는 비트의 수에 비례함. (Ex. 8비트 -> 2^7 - 1 부터 2^7 + 1까지 표현됨, 제곱수가 8이 아닌 7인 이유는 한 비트가 부호표현에 할당되었기 때문)
    -> 보수
      -> 2의 보수는 1의 보수에 +1
      -> 2의 보수의 표현 범위는 -(2^(n-1)) ~ +(2^(n-1)-1)로, 부호와절대값이나 1의보수보다 '1' 더 많다.
10진정수 -> IBM 대형컴퓨터(가 EBCDIC 코드를 사용하기 때문)에서 사용
  -> PACK : 연산가능이지만 출력이 불가
    -> F1, F2, F3
  -> UNPACK(ZONE) : 연산이 불가하지만 출력가능
    -> 12, 3F
    -> 양수는 A, C, E, F / 음수는 B, D를 사용
실수 -> 128 bias가 가장 많이 쓰임
  -> 64 bias : 16진수로 구성됨
    -> 16진수화 : Noamalization(정규화)라고 부름 -> 소숫점 뒤에 0이 아닌 유효숫자가 나오도록 구성한다.
    -> 지수와 가수
  -> 128 bias : 2진수로 구성됨
    -> Normalization 거침
    -> 
  -> 127 bias : 2진수로 구성됨
    -> Normalization 거침 -> 소숫점 앞에 유효숫자가 옴
    -> 
  -> 128 bias와 127 bias의 지수분은 다르고 가수분은 같음.

컴퓨터에서 ->
정수 : fixed point number
실수 : floating point number -> 숫자 사이에서 포인트(.)가 부유(float)해서.

- 2진수 변환

<br>

# linear, 선형구조 (배열)

- Queue
- Stack
- Deque

<br>

# Non-linear, 비선형구조

- Tree
- Graph

<br>

---

03/21 : 알고리즘

# 알고리즘 (PDL이라고도 표현 -> Program Design Language): 문제를 해결하기 위한 단계적인 절차와 과정, Or, 명령의 집합.
  - 알고리즘의 작성 pseudo code를 사용한다.
  - 알고리즘은 입력, 출력, 명확성, 유한성, 실제성의 조건을 만족한다.
  - 알고리즘의 분석을 위해 Time complexity(시간복잡도)와 space complexity를 사용한다.
  - 시간복잡도는 특정 문제 해결을 위한 연산의 빈도수를 차수(degree)로 표현함.
  - O(1), O(log n), O(n), O(nlog n), O(n^2), O(2^n), O(n^m), O(N!) 등으로 표현한다.
  - Big O 표시법은 연산 차수가 가장 높은 것을 알고리즘 계산 차수로 사용한다. : 시간복잡도의 상한
    - f(n) = O(g(n))꼴로 나타냄
  - 옴(Ω) 표시법은 연산차수가 가장 낮은 것을 알고리즘 계산 차수로 사용한다. : 시간복잡도의 하한
    - f(n) = Ω(g(n))꼴로 나타냄
  - Big O 표시법과 Ω 표시법은 교집합이 되는 표시법을 Θ-표시법으로 나타내며, <<최적 알고리즘>>으로 사용한다.

  - 알고리즘 -> 디자인 단계에서 작성(조용재)
  
  - 참고사항 : 순서도, UML (-> PDL의 대표적 예시로서, "의사코드"라고 부름)

03/22 : ??

# 순서 리스트
- Segmential list, linear list : 순서 리스트는 데이터가 연속적으로 기억 장치에 저장 및 처리되는 구조 
  - A = {a1, a2, a3, a4, a5...}
- 배열(Array)
  - 배열명은 주솟값을 가진다.
  - 연속적으로 배치된 기억장소의 형태이며, index와 값을 mapping한다.
  - 연속적인 기억장소에 1개의 블록으로 존재한다.
  - 2개 이상의 변수가 공통적인 성질을 가지고. 하나의 변수와 첨자를 이용한다.
  - 배열이 사용되는 언어에 따라 행중심(row oriented)과 열중심(column oriented) 배열로 구분한다.

- 첨자와 인덱스 : 첨자는 ['0'], ['1'], ['2'], 인덱스는 'k[0]' 그 자체.

int k[3] = {10, 20, 30};일 때,
k[0]의 값은 10이고 주솟값은 예를 들어 1000.
k[1]의 값은 20이고 주솟값은 1004.
k[2]의 값은 30이고 주솟값은 1008. (물론, 주솟값은 16비트로 표현될 것이다...?)

```c
for (i=0; i<3; i++){
  print("%d %p \n", %k[0], %k[0]);
}
```

- 2차원, 3차원 배열도 결국엔 1차원 순서로 나타낼 수 있다.

- 2차원, 3차원 배열 해두셈!
  - 2차원 배역 => "행렬렬"
  - 3차원 배열 => (면, 행, 열) 순서. 교수님 기준으로는 나와 가까운 면이 '1'면임.

- 3차원 배열 (u1, u2, u3)에서 특정위치 (i1, i2, i3)의 위치는 : location = i1*u2*u3 + i2*u3 + i3

- 면 : page
  행 : row
  열 : column

- 구조체, 문자열

---

3월 28일 

- *** 인덱스가 0이 아닌 1부터 시작하는 경우 ***

  - (2차원 배열의 경우)
    - 행 중심 : (1, 1)다음이 (1, 2).
    - 열 중심 : (1, 1)다음이 (2, 1).
    -> 배열의 크기가 (m, n)일 경우, 특정위치 (i, j)는 :
      - 행 중심일 경우 : n(i - 1) + j,
      - 열 중심일 경우 : m(j - 1) + i가 된다.

  - (3차원 배열의 경우)
    -> 배열의 크기가 (p, m, n)일 경우, 특정위치 (k, i, j)는 :
    - 행 중심 : m * n (k - 1) + n (i - 1) + j
    - 열 중심 : m * n (k - 1) + m (j - 1) + i

-> 배우는 이유 : C언어는 행 중심, 0부터 시작하는 언어지만 타 언어의 경우 열 중심, 1부터 시작하는 언어일 수도 있기 때문



* Spaese matrix(희소 행렬)
  - 2차원 배열에서 공집합(= 0)인 요소가 대부분을 차지하는 경우, 즉 공집합(= 0)이 아닌 요소가 매우 적은 행렬.
  - 공집합(= 0)이 아닌 요소를 별도로 저장하면 원래 행렬보다 기억장소를 50% 이상 절약!! 할 수 있다.

  희소행렬 예시) int sparse[8][8] = {{0, 0, 0, 0, 0, 6, 0, 0},
                                    {0, 0, 0, 14, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 5, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 0, 0},
                                    {0, 0, 2, 0, 0, 0, 0, 0},
                                    {0, 0, 0, 3, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 7, 0}}

  희소행렬 활용 예제 => 찾아보기
    - 중첩 for문을 이용해 일반 행렬로 변환하여 출력해서 사용...? => 왜 메모리가 절약

---

3월 28일

  - 구조체 : "레코드"의 일종이다.

    - 예시
      ```c
      struct list {
        char name[15]; -> 15바이트 할당
        int no;        -> 디폴트 4바이트 할당
      }

      ```c
      int main()
      {
        struct list k;
        k.name = "kim";

        struct list k[3];
      }
  
      ```c
      int k = 31;
      int *p, **pp;

      p = &k;
      pp = &p;

      k += 1;
      (*p)++;
      (*pp)++;

      print("k = #d", k);
      ```
      -> 출력 결과 : k = 31에 1이 총 3번
         (예를)
         더해져서 34가 출력된다.

      ```c
      char k[5] = "ab";
      char *k1 = "cd";

      print("%s %s\n", k, k1);
      ```
      -> k는 배열의 이름 자체가 주솟값을 가지기 때문에, *를 붙일 필요가 없음.



  - String

    - char k[5] = "ab";  -> {'a', 'b', 'null', 'null', 'null'}으로 저장됨
    - char k[5] = {'a', 'b', 'null', 'null', 'null'}; -> 위와 같은 의미의 다른 표현.

    - char *str = "com"  -> 저장소에 'c', 'o', 'm', 'null' 런 식으로 저장됨
    - print("%s %s \n", k, str+2);로 실행해 볼것.

  - *포인터 배열*
    - char *str[3] = {"ab", "cd", "ef"};

---


4월 4일

- %p, %s

- stdio.h에 선언되어 있는 puts, putchar 함수?

```c
//print("k[0] 주소 : %p" &k[d])

int main()
{
  char *k[3] = {"ab", "cd", "efg"}; // 각 배열 요소마다 e, f, g, >null< 기준으로 4바이트씩 메모리가 확보됨, 가장 긴 요소를 기준으로 확보되기 때문에 모두 4바이트씩 지정된다.
  char *p1, *p2, *p3;

  p1 = k[0];
  p2 = k[1];
  p3 = k[2];

  printf("%p \n" p1);
  printf("%p \n" p2);
  printf("%p \n" p3);
}

// 혹은,

printf("%s \n", p1);
puts(p2);
while(*p3 != i0(->null?));
  putchar(*p3++);
return 0;
```

- #include <string.h>에 대해서
  - null을 포함하지 않는 길이를 반환하는 함수 포함함
  - 콜리지
  - cpy
  - str 캣



- 선형 리스트, linear list OR Segmential list, -> 주로 배열을 이용하여 사용하게 된다 : 순서를 가진다는 것이 핵심이다.
  - 기억장소에 연속적으로 저장되며, 원소 (atom, node | 부연설명 : 데이터를 노드, 아톰으로 표현함.)들간에 "순서"를 가지는 리스트임.
  - 기억 장소 활용도가 좋으며, 자주 변경되지 않는 데이터임.
  - 저장에 유리함.
  - 여분의 기억공간이 확보되어 있지 않으면 데이터를 추가할 수 없으며, 추가와 삭제시 많은 데이터의 이동이 필요함. -> 처음에 정의한 배열의 크기대로 굴러가게 됨.
  - n개의 데이터에서 k번째 데이터 추가시 (n - k + 1)번의 데이터 이동이 필요하며, 데이터 삭제시 (n - k)번의 데이터 이동이 필요함.
    - 추가시 평균 이동 횟수 = (1/n) * (n)E(k=1){n - k + 1} (*E -> 시그마)
      - 왜? Ex.
        1. [5, 6, 14, 27, 31]에 15를 추가하고 싶다면,
        2. [5, 6, 14,   , 27, 31]처럼 뒤 2개를 이동시키고,
        3. [5, 6, 14, 15, 27, 31]처럼 15를 적절한 순서에 맞추어 데이터를 넣어야 할 것이다.
        4. 이 때 이동 횟수는 5 - 4 + 1 = '2'가 될 것.
    - 삭제시 평균 이동 횟수 = (1/n) * (n)E(k=1){n - k}
      - 왜? Ex.
        1. [5, 6, 14, 15, 27, 31]에서 6을 삭제하고 싶다면,
        2. [5, 14, 15, 27, 31]처럼 뒤 4개 데이터가 순서를 이동해야 할 것이다.
        3. 이 때 이동 횟수는 6 - 2 = '4'가 될 것.

- 링크드 리스트, linked list
  - 처리할 데이터의 포인터를 가지는 리스트이다.
  - 기억장소에 데이터가 연속적으로 저장되어 있지 않아도 포인터를 이용하여 처리가 가능하다.(->장점)
  - 그러나 포인터 값으로 인한 기억장소의 낭비와 처음부터 데이터를 탐색해야 하는 단점이 있다.
    - 예시
    ```c
    struct list {
      char name[10];
      int no;
      struct list *link; -> 포인터
    }
  - 구조 : |data|pointer|
  - 추가 Algorithm |---|P(i)| -x-> |---|P(i+1)|
                        ㄴ-->|---|P(new)-->           (그냥 새로 추가하면 됨.)
    - 새로운 노드의 생성 -> 기억장소를 할당 -> malloc() 함수를 통해 해결 (memory allocate)
  - 삭제 Algorithn |---|P(i-1)| -> |---|P(i)|         (그냥 바로 삭제하면 됨.)
    - 노드의 삭제 -> 기억장소를 해제 -> free()

    단, 위의 malloc() 혹은 free()를 사용하기 위해선 #include <stdlib.h>를 통해 라이브러리를 선언해주어야 함.

---

4월 5일



* 문제 1번 :
구조체 형의 포인터 함수 inp() : 이름과 전화번호 입력, 구조체 변수에 저장 후 return, main()에 출력하기.

* 풀이
```c
# include <stdio.h>
# include <stdlib.h>

struct list {
  char *nam;
  char *tel;
};

struct list *inp(struct list *m);
struct list *nalloc();

int main()
{
  struct list *man, *p; // 구조체 이름이 list임, 별다른 의미 X

  man = NULL;

  p = nalloc();
  p = inp(man);

  printf("%10s %10s", p->nam, p->tel);
  free(p->nam); // 기억장소를 해제하고
  free(p->tel);

  return 0;     // 종료한다.
}



struct list *nalloc()
{
  return ((struct list *) malloc(sizeof(struct list)));
}

struct list *inp(struct list *m)
{
  char *name1 = (char *)malloc(10); // char *name1;로만 선언하면 정확히 안 나옴...
  char *tel1 = (char *)malloc(10);

  m = nalloc();

  scanf_s("%10s %10s", name1, 10, tel1, 10); // ㅇ이 줄에서 10은 할당되는 비트수를 의미

  m -> nam = name1;
  m -> tel = tel1;

  return(m);
}
```

* 예시 입출력
(입력 -> kim, 100) -> (출력 -> kim, 100)

* 비고
프로그램에 오류 없음



* 문제 2 :
3개의 노드를 생성하여 linked list 구현 -> 차례대로 출력 -> 기억장소 해제

* 풀이

예를 들어 다음의 노드가 있다 : |이름|점수|   ---    | 
    가령, 첫 번째 노드(헤드)는 |kim|100 |2번째 노트값|,
         두 번째 노드는       |lee |90 |3번째 노트값|,
         세 번째 노드는       |choi|80 |   NULL   |로 구성해야 할 것이다.

```c
# include <stdio.h>
# include <stdlib.h>

struct list {
  char nam*[10];
  int score;
  strict list *link;
};

int main()
{
  struct list *list1, *head. *pre, *next;
  
  head = NULL;
  
  int i;
  for (i=0 i<3 i++) {
    list1 = ((struct list *) malloc(sizeof(struct list))); // 명시적 변환 포함되어있음을 주목. i = 1일 때 malloc이 새로 실행되며 list1은 새 주소값을 가지게 된다.
    
    ;// (if (list1 == NULL) return -1;) -> 입력 못 받은 경우에 대한 처리, C언어 버전별 처리를 용이하게 하기 위함

    scanf_s('%s %d', list1 -> name, 10, &(list1 -> score)); // 문자열과 정수는 & 통해 다르게 취급

    // 링크 생성시 초기 1번만 수행
    if (head == NULL) {
      head = list1; // 이 시점에서 list1은 주솟값을 가지고 있다.
    } else {
      pre -> link = list1;
    }

    list1 -> link = NULL;
    pre = list1; // i = 0일 때, 이 지점에서 list1, head, pre는 모두 malloc()로 생성한 노드에 대한, 같은 값을 가지고 있다.
  }

  for (next = head   next != NULL   next=next->link) {
    print("%s %d \n", next -> name, next -> score);
  }

  while (head != NULL) {
    next = head -> link; // next 변수가 활약하는 지점
    printf("삭제 완료 (%s %d ) \n", head -> name, head -> score);
    free(head);
    head = next; // 2번째 노드를 기억장소에서 해제하기 위함
  }

  return 0;
}

* 비고
노드 구조를 그려서 이해하길 바람.
첫번째 : |  |  |  |, 두번째 : |  |  |  |, 세번째 : |  |  |  |.

---

4월 11일

<링크드 리스트 추가 정리>

'다중 링크드 리스트' -> 포인터 여러개를 사용함
'이중 링크드 리스트' -> 리스트의 값 모두가 두 개의 링크부를 가짐. 그들이 서로 반대 방향으로 선행 수속 노드를 가리키게 함.
  - left link, right link가 있음 : 각 다음 노드와 이전 노드를 포인터로 알려주는 구조임.
  - 선언은 llink와 rlink를 포인터로 선언 (구조체 이용함).
'단일 링크드 리스트'의 마지막 링크에 리스트의 처음 노드를 가리키도록 구성하면 '환영 링크그 리스트'가 된다.
'이중과 환영 링크드 리스트'를 합한 것이 '이중 환영 링크드 리스트'가 된다. -> 처음은 마지막, 마지막은 처음을 가리키는 구조임. 

  -> 검증 및 수정 필요

- 추상 리스트가 아닌 것 : 트리
- 비 선형구조(트리, 그래프)와 선형구조(큐, 스택, 연결 리스트) 구분 필요

```C
struct list {
  char *name;
  int no;
  struct list *next;
}

int main() {
  struct list k[3] = {{"ab", 10}, {"cd", 20}, {"ef", 30}};
}



<Stack>

스택 : 원소의 추가&삭제가 리스트 한쪽 끝 부분인 top에서만 수행되는 선형 리스트이다. -> 양쪽 끝에서 입출력이 이루어지는 데이터구조도 있는데, 그것이 Queue.

탄창처럼, 마지막에 넣은 총알이 제일 먼저 나가고, 처음에 넣은 총알이 제일 구석쪽으로 이동하는 원리이다.
입출력이 이루어지는 곳을 top, 반대편 끝을 bottom이라고 부른다.

LIFO(Last-In, First-Out) 구조이며, 데이터의 입력 동작을 push동작, 출력동작을 pop동작이라고 부른다.
시스템에서 함수 호출, 수식계산, 포스트픽스(post fix)한다.

top은 데이터 입력 시 top은 top + 1을, 데이터 삭제 시 top - 1을 수행한다.

stack 구조 : 
```
 0 1 2 3
|  |  |  |  |
top
```
-> top 포인트는 0
```
 0 1 2 3
|10|  |  |  |
  top
```
-> top 포인트는 1, bottom은 0번째.

... 스택의 추가 알고리즘은, 코드로 구현하자면, 다음과 같이 나타낼 수 있다 :
if (top >= n) overflow;
stock[top] = data;
top += 1;

스택의 삭제 알고리즘은, 코드로 구현하자면, 다음과 같이 나타낼 수 있다 :
if (top == 0) underflow;
top -= 1;
stock[top] = NULL;

-> overflow && underflow 개념 중요한듯?

- overflow : 추가가 불가능함

.
.
.

어떨 때 쓰는가?

** 첫 번째 예시 **
void a() {
  void b();
};
void b() {
  void c();
};
void c();

int main()
{
  a();
}

구조에서 사용한다. 함수호출시 컴파일러가 내부적으로 스택을 사용하여 복귀주소를 저장하여 처리한다. LIFO 구조의 장점을 이렇게 활용함.

** 두 번째 예시 **
A + (B * C) / D 를 수행할 때 컴파일러가 내부적으로 스택을 사용하여 처리한다.

그럼 이제, postfix가 무어냐.
Infix   : A+B
Prefix  : +AB
Postfix : AB+
수식 연산시 Postfix를 사용하여 연산하기 때문에 스택을 이용한다고 볼 수 있다.

-> 배열을 Top부터 읽어들이며 <연산자, 변수, 변수> 순서열에 부합할 때 국소적 위치에서의 수식을 계산하여 R1, R2, R3을 계산한다.

A + (B * C) / D를 Postfix식으로 나타내면, ABC*D/+가 되는데, BC*를 계산해서 R1를 만들고 R1D/를 계산해서 R2, AR2+를 계산해서 R3을 만드는 식이다.
-> 컴파일러단에서 산술식을 번역할 때 Stack이 쓰임.



```c
int main()
{
  int i=31, j=6;
  {
    int i=37;
    printf("i = %d, j = %d \n", i, j);
  }
  printf("i = %d, j = %d \n", i, j);
}

이 경우에 i와 j를 위한 Stack이 잡힌다. 처음엔 i=37로 출력되지만 이후 i=31로 출력됨.



** 변수의 통용 범위 **
- auto : 스택할당 -> 변수처리
- static : 기억장소 할당 -> 변수처리
- extern : 서로 다른 프로그램에서 정의한 변수가 서로 영향을 줌.
- register : CPU 내의 임시기억장소, 그게 맞음. extern까지는 주기억장소에 할당하지만, register는 아예 레지스터단에 변수를 할당함. ㄷㄷ

static과 extern은 1개의 기억장소를 할당한다.

---

4월 12일

```c
int i = 6, j = 31;

kbs()
{
  int i = 14;
  printf("%d", i); // i = 14가 출력됨
}

printf("%d", i); // i = 6이 출력됨
```
이 경우는 암묵적으로 auto변수가 할당됨. (auto) int i = 6, j = 30;



Infix, Prefix, Postfix 살짝 더 자세히 나감.
컴파일러에 따라 스택을 2개를 사용하는 경우도, 1개를 사용하는 경우도 있다.
수식을 옮길 때 위치를 정확히 반영하여 옮겨야 한다. Ex. (B+C)*E -> Postfix) BC+E*이지 EBC+*가 아니다.

---

4월 18일

큐(Queue)
- 데이터의 입출력이 양쪽 끝 방향에서 수행됨
- FIFO(First-In, First-Out) 구조이다. => LIFO구조의 스택과 차이를 보인다.
- 2개의 변수 tail(=rear), head(=front)를 사용하여 입출력을 제어하며, 추가시 tail += 1을 수행하고 삭제시 head += 1을 수행한다. => top 변수 1개만을 사용하던 스택과 차이를 보인다.
- 운영체제 시스템에서 프로세스(=실행중인 프로그램)의 순차처리, SpooL(Simultaneous Pheripheral Operation On Line => 출력작업) 처리 등에 사용한다.

<!--동작 원리-->
queue
  0   1   2   3   4
|   |   |   |   |   |
head
tail

  0   1   2   3   4
|10 |20 |30 |   |   |
head    tail

  0   1   2   3   4
|   |20 |30 |   |   |
    head tail
<!--"이 때 비어버린 Queue[0] 자리에는 값을 추가할 수 없다."는 단점이 있는데, 이를 해결하기 위한 방법은 밑에서 이어 설명-->

  0   1   2   3   4
|   |   |   |   |   |
        head    
        tail

<!--실제 코드-->
```c
int queue[5];
int head = NULL, tail = NULL;

// Queue의 기본적인 데이터 추가 알고리즘
if (tail >= n) overflow;
queue[tail] = data;
tail += 1;

// Queue의 기본적인 데이터 삭제 알고리즘
if (head == 0 && tail == 0) underflow;
if ( head < tail) {
  queue[head] = NULL;
  head += 1;
  if (head == tail) {
    overflow,
    return
  }
}

// head와 tail의 포인터값 관찰하고 이해하는 것이 중요하다.

"이 때 비어버린 Queue[0] 자리에는 값을 추가할 수 없다."라는 이슈는 head와 tail의 포인터값을 후퇴시킴으로서 복구가 가능하며, 이에 따라 추가공간을 확보할 수 있는데, 이렇게 보완된 큐를 Moving Queue라고 한다.

-> 그러나 기본적인 Queue도 Moving Queue도 실제로는 불리하고 불편하기 떄문에 사용되지 않으며, 실제로 사용되는 것은 보완 된 Queue의 보완된 Queue인 Circular Queue를 사용한다.

# Circular Queue
원형 큐에서는 시작점과 끝점이 연결되어 있다.
Ex. 이 Queue에서는 head = 4, tail = 1 같은 상황이 가능하다.

---

4월 19일

Circular Queue -> 나머지 연산자(%)를 이용한다. -> 당연함.
Circular Queue를 구현하는 핵심 키워드(알고리즘)은 '나머지 연산자(%)'이다.

=>
데이터 추가시 tail = (tail + 1) % n
데이터 삭제시 head = (head + 1) % n

# 아래 2 알고리즘의 공통 코드
```c
int Q[5];
int head = tail = NULL;
```

# Circular Queue의 추가 알고리즘
```c
tail = (tail + 1) % N

if (head == tail) {
  if (Queue[tail] = NULL) {
    Q[tail] = data, overflow, return;
  } else {
    overflow, return;
  }
}

Queue[tail] = data;

# Circular Queue의 삭제 알고리즘
```c
if (head == tail && Q[head] = NULL) overflow, return;
head = (head + 1) % n;
Q[head] = NULL;
```

환영 큐는 이동 큐의 문제점을 보완, 이동 큐는 기본 큐의 문제점을 보완.
환영 큐에서도 tail, head가 같은 곳을 가리키면 overflow될 수 있음.

다중 스택 -> 말 그대로 스택이 여러개 -> Ex. 2차원 배열을 다중 스택으로 표현 가능
다중 큐   -> 말 그대로 큐가 여러개   -> 그러나 큐는 순서를 가질 수 있다.
          -> Ex. "우선순위 큐"
          -> DEQ -> Double Embedded Queue -> 입력 제한 DEQ(입력만 한 쪽 끝에서, 입력은 양쪽에서) && 출력 제한 DEQ(출력만 한 쪽 끝에서, 입력은 양쪽에서)

---

5월 2일

"트리(Tree)" : 계층적인 원소를 표현할 때 사용된다.
그래프의 일종이며, 비선형구조임.

[용어]
root node : 가장 상위의 노드
Parent node(부모노드) & child node(자노드) : 이름이 직관성을 띄고 있으므로 메모 X
sibling : 동일한 부모노드를 공유하는 노드
level : 부모 & 자노드의 순서
depth : 최대 레벨의 수 *in-degree가 있고 out-degree가 있음.
degree : 트리에서 최대 간선(= 하나의 노드에서 파생되는 노드의 수)의 수
ancestor : 정확한 개념 잡기 필요함
terminal : 단말(= 말단) 노드
non-terminal : 
forest : 루트 노드 제거시의 서브 트리(부분 트리)의 모임

하나의 root node가 존재한다.
root node에서 edge로 나른 노드를 연결한다.
cycle을 형성하지 않는다.
root node 제거시 T1, T2, T3.... Tm의 분리된 서브트리의 모임으로 구분한다.

[종류]
1. full-binary Tree(정이진 트리) : 노드의 수가 2^k - 1인 트리(k : depth)
  달리 말하면, 파생 노드(degree)가 2인 트리를 말한다.
2. complete binary Tree(완전 이진 트리) : 노드의 수가 2^(k-1) < n < 2^k - 1인 트리
3. skwed tree(사향 트리) : 한쪽 방향으로 치우친 트리
4. knuth binary tree(누스 이진 트리)
  파생 노드(degree)가 1인 트리를 말한다.

[표현]
1. 배열을 이용하는 방법 : 부모 노드에 대한 접근이 용이하며, full-binary tree인 경우 기억장소 활용도가 좋으며, 데이터의 추가와 삭제시 많은 데이터의 이동이 필요하며, skwed tree인 경우 기억 장소가 낭비된다.

1. ExampleOne

      a
  b       c
d   e   f   g

이 경우 배열의 1, 2, 3, 4... 번째 순서는 a, b, c, d, e, f, g가 된다.
+ 단말노드는 d, e, f, g이다.

2. ExampleTwo

    a
  b
c

이 경우 배열의 1, 2, 3, 4... 번째 순서는 a, b, -, c, - - - -가 된다.

: 트리의 각 노드의 순서는 글의 쓰는 순서를 따라 1, 2, 3, 4, 5, 6...을 할당한다.



배열에서 한 노드의 -
부모 노드 찾는법 : i/2.
왼쪽 자(子)노드 찾는법 : 2i
오른쪽 자노드 찾는법 : 2i + 1


<b>
Linked list를 이용
- 트리의 구현에서 linked list를 사용
- n개의 노드를 가진 k진(= 최대 차수) tree에서
  - n * k개의 링크
  - n(k-1) + 1개의 널링크

- k진 tree를 2진 tree로 변경시 링크로 인한 기억장소 낭비 감소
  - 형제 노드를 가장 왼쪽 자노드의 자노드로 변환
  ex. 
     a       =>      a
  b  c  d         b
                     c
                        d

-> 트리는 대부분 3,4,5진 트리를 2진 트리로 구현을 한다.
</b>

struct list {
  struct list *llink;
  char *data;
  struct list *rlink;
};

---

5월 3일

전 수업에 이어 트리를 다룸.

[운행]
- 트리의 노드를 중복되지 않게 탐색하기 위한 방법
  - InOrder(주기운행법) : left node, root, right node
    - 서브트리 내에서도 동일하게 적용된다.
  - PreOrder(전이운행법) : root, left node, right node
  - PostOrder(후이운행법) : left node, right node, root

Ex.
      a
  b       c
d   e   f   g
          h

bde와 fcgh를 서브트리로 묶을 경우,

Inorder.
(d, b, e), a, (f, c, h, g)로 탐색된다.
Preorder.
a, (b, d, e), (c, f, g, h)로 탐색된다.
Postorder.
(d, e, b), (f, h, g, c), a로 탐색된다.



[연산식의 표현]
F = A + (B + C) / D - E의 식을 트리로 표현하면 :

  =
F   -
  +   E
A   /
  *   D
B   C

위의 수식을 각 order로 정리하면:
Inorder : F = A + B * C / D - E
Preorder : = F - + A / * B C D E 
Postorder : F A B C * D / + E - =

-> 트리로 표현된 수식을 Postorder로 표현하면 연산처리가 가능하다.
-> infix, leftfix, postfix



[Thread binary tree]
- 사용되지 않는 NULL값을 tree의 운행에 사용함.
  - 특정 노드값의 앞뒤에 있는 것을 null 포인터 값을 이용하여 바로 파악하자는 발상임.
- n개의 노드를 가진 2진 tree는 2n개의 링크, n + 1개의 널링크를 가진다.
- 노드의 구조
| lbit | llink | data | rlink | rbit |
 lbit가 0이면 thread pointer    rbit가 0이면 thread pointer
        1이면 정상 pointer             1이면 정상 pointer

Ex.
          a
null  b       c    null
    d   e        f

Inorder : d, b, e, a, c, f

| 노드 | llink | rlink | lbit | rbit |
|---|---|---|---|---|
| a | b | c | 1 | 1 |
| b | d | e | 1 | 1 |
| c | a | f | 0 | 1 |
| d |NULL| b | 0 | 0 |
| e | b | a | 0 | 0 |
| f | c |NULL| 0 | 0 |

Preorder : a, b, d, e, c, f


| 노드 | llink | rlink | lbit | rbit |
|---|---|---|---|---|
| a | b | c | 1 | 1 |
| b | d | e | 1 | 1 |
| c | e | f | 0 | 1 |
| d | b | e | 0 | 0 |
| e | d | c | 0 | 0 |
| f | c |NULL| 0 | 0 |



교재 예시 Tree
      a
  b       c
d   e   f   g
  h       i   j

Inorder : (d, b, h, e), a, (f, e, i, g, j)
Preorder : a, (b, d, e, h), (c, f, g, i, j)
Postorder : (d, h, e, b), (f, i, j, g, c), a
+ familyorder : (a, (b, (c, f, (g, i, j)), d, (e, h))) (스택구조 : First-In && First-Out)

하향식, 상향식
노드 생성을 위한 함수 : 데이터값이 크면 오른쪽 자노드에, 작으면 왼쪽 자노드에 배치

Ex.
[Kim, Lee, Choi, Park]

    Kim
Choi   Lee
          Park



---

5월 10일

"Graph"

<핵심>
정점과 간선의 수는 몇 개인지 따져서 어떤 그래프인지 분류하기.

[정의]
정점(Vertex)와 간선(edge)로 구성된 자료구조.
  - 그래프는 예를 들어, 지도에서 이용될 수 있다.

V(G) = {1, 2, 3, 4}
  - V는 Vertex를 의미, 1부터 4까지 4개가 있다.
E(G) = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}
  - E는 Edge를 의미, Vertex 사이끼리 연결된 간선 정보를 의미한다.

[용어]
Adjacency
  - 2개의 정점이 간선으로 연결
Path
  - 한 정점에서 임의 정점에 이르는 경로
Length
  - 간선의 수, 또는 간선의 가중치의 합
Loop
  - 정점 자기 자신으로 오는 경로가 존재
Cycle
  - 시점과 종점이 동일한 그래프
Distancy
  - 최단 경로의 길이

[종류]
Sub graph
  - G의 임의 정점으로 구성된 그래프 (최소 1개이상)
Directed graph (방향 그래프)
Undirected graph (무방향 그래프)
Multiple graph
  - 인접한 두 정점사이의 간선이 2개 이상인 그래프
Regular Graph (정규 그래프)
  - 모든 정점의
Complete Graph (완전 그래프)
  - 무방향 그래프에서 간선의 수가 n(n-1)/2 인 그래프
Isomorphic graph
  - 2개 그래프 G1, G2의 정점의 수, 차수의 수, 산선의 수가 동일한 그래프
I-lamilton graph
  - 모든 정점을 1번만 통과하고, 시점과 종점이 같은 그래프
Euler Graph
  - 모든 정점의 차수가 짝수인 그래프

[표현]
1. Adjacency Matrix(행렬)
  - N개의 정점으로 구성된 그래프 G를 2차원 배열로 표시하며, Vi와 Vj가 인접하면 1, 그렇지 않은 경우 0으로 표시.

  1  
2   3
  4

G = [0 1 1 1
     1 0 1 1
     1 1 0 1
     1 1 1 0]

2. Adjacency list
  - 그래프 G의 한 정점을 하나의 링크드 리스트로 표현함.
  - N개의 정점을 가진 리스트는 N개의 링크드 리스트로 표현되며, 간선으로 인한 중복 링크의 발생으로 기억장소가 낭비될 수 있음.
    - 왜냐하면, 각 간선이 2번씩 중복되기 때문이다. 예를 들어, 아래의 예시에서는 (1) 버텍스에서의 {1, 3}과, (3) 버텍스에서의 {3, 1}이 중복되고 있다.

(1) -> {2, {3, {4, NULL}}} (실제로는 두 번째 기억장소가 다음 리스트를 가리킴.)
(2) -> {1, {3, {4, NULL}}}
(3) -> {1, {2, {4, NULL}}}
(4) -> {1, {2, {3, NULL}}}

3. Adjacency multiple list
  - 중복되는 간선을 고유한 노드에 저장하여 여러 list로 하여금 공유하여 Adjacency list의 단점을 보완한 list.
  - 노드의 구조
    - |간선|Vi|Vj|Vi링크|Vj링크|
    - S22 Ultra 삼성노트 필기 참조

---

5월 16일

그래프의 종류

[운행]
1. DFS (Depth First Search, 길이 우선 탐색)
  - 그래프 G를 인접리스트로 표현하고, 정점의 개수에 해당되는 배열을 이용하여 방문 정점 여부를 체크하는 방식이다.
  - 알고리즘 : 1. 시작정점 V를 결정하고 방문한다.
              2. V에 인접한 정점 가운데 방문되지 않은 정점을 방문한다.
              3. 모든 인접한 정점을 방문한 정점을 만나면 방문되지 않은 인접한 마지막 정점을 가지고 수행한다.
              4. 모든 정점을 방문하면 작업을 종료한다.

      0        (0은 1,2)
  1       2    (1은 3,4) (2는 5,6)
3   4   5   6
      7        (7은 3,4,5,6)과 연결되어 있음.

|0| -> [1 | [2 | NULL]]
|1| -> [0 | [3 | [4 | NULL]]]
|2| -> [0 | [5 | [6 | NULL]]]
|3| -> [1 | [7 | NULL]]
|4| -> [1 | [7 | NULL]]
|5| -> [2 | [7 | NULL]]
|6| -> [2 | [7 | NULL]]
|7| -> [3 | [4 | NULL]]

|0|1|2|3|4|5|6|7|
|0|0|0|0|0|0|0|0| => 0은 미방문, 1은 방문.
방문하지 않았을 때에는 0이지만, 방문하면 1로 변경하는 방식임.

이 경우, 방문 순서는 0, 1, 3, 7, 4, 5, 2, 6이 된다.


2. BFS (Breadth First Search, 너비 우선 탐색)
  - 그래프 G를 인접행렬과 큐를 사용하여 탐색하는 방식이다.
  - 알고리즘 : 1. 시작정점 V를 결정하고 방문한다.
              2. V를 큐에 저장하고, V에 인접한 정점을 큐에 저장하고, 큐의 내용을 출력하며, 인접한 정점을 가지고 2번 과정을 반복한다.
              3. 큐가 underflow되면 작업을 종료한다.

      0        (0은 1,2)
  1       2    (1은 3,4) (2는 5,6)
3   4   5   6
      7        (7은 3,4,5,6)과 연결되어 있음.

같은 상황에서,

0, 1, 2, 3, 4, 5, 6, 7 차례대로 출력됨.
( |0|1|2|3|4|5|6|7| 큐 이용. 0이 큐에 저장, 0에 인접한 1, 2가 큐에 저장, 1에 인접한 3, 4가 큐에 저장, 2에 인접한 5, 6이 큐에 저장...)



6. Spanning Tree
- 그래프 G의 모든 정점을 포함한 tree => 사진, 자료 참고
- 간선에 가중치가 있고 없는 방식이 있는데, 그 중 간선의 가중치를 가지고 Cycle(순환)되지 않는 Spanning Tree를 구성하기 위한 순서를 정하는 방법 :
  - Prim 방법 : 간선의 가중치를 가지고 ?? => 자료 찾아보기
  - Kruskul 방법 : 간선의 가중치를 가지고 ?? => 자료 찾아보기



7. Shortest Path
  - 그래프 G의 한 정점에서 임의 정점에 이르는 최단경로를 구하는 방법이다.
  - A^k[i][j] : k보다 큰 정점을 지나지 않고, 정점 i에서 정점 j로 가는 최단 경로이다.

  - 가중치의 합을 행렬의 각 원소로 나타내어 정리함.

  ---

5월 17일

"임계 경로(Critial Path, 최장 경로의 의미임)"



Sort(정렬)
- 데이터를 일정 기준에 따라 재분류하는 작업이다.
- 작업 결과에 따라 Ascending Sort(오름차순, 점점 커짐)와 Descending Sort(점점 작아짐)로 구분한다.
- 종류
  - 삽입법 : Insertion, Shell
    - 이미 정리되어 있는 서브 파일에 한 개의 레코드를 입력하여 정렬
    - 
  - 교환법 : Bubble, Selection, Quick(가장 빠름)
    - 위 두개는 알고리즘
  - 선택법 : Heap
  - 병합법 : 2-way merge
  - 분배법 : Radix (큐 이용)
    - 위 세개는 방법론

1. 삽입(Insertion)정렬 알고리즘

a 0  1 2 3  4
 |14|6|5|31|27|가 있다고 하자. 이는 코드로 아래와 같이 표현될 것이다.
```c
int a[5] = {14, 6, 5, 31, 27};
```

이 알고리즘은 변수와 변수를 비교하여, 비교대상보다 값이 작으면 위치를 변경하는 식으로 작동한다. 이를 C언어로 표현하면 아래와 같다.

```c
int a[5] = {14, 6, 5, 31, 27};
int imsi, count, i;

for (i = 1; i < 5; i ++){
  imsi = a[1];
  count = i - 1;

  while (count >= 0 && imsi < a[i]) {
    a[count + 1] = a[count];
    count = count - 1;
  }

  a[count + 1] = imsi;

  for (k = 0; k < 5; k ++){
    printf("%d ", a[k]);
  }
  print("\n");
}
---

5월 23일

2. 버블(Bubble)정렬 알고리즘
- 인접한 2개 데이터를 비교해가면서 정렬을 수행하며, pass 수행 후 가장 큰 값을 맨 뒤에 배치하고, 이 값은 다음 pass 단계에서 제외하는 식으로 작동하는 정렬법이다.

```c
int a[5] = {14, 6, 5, 31, 27};
```

위 배열은, 첫 번째 pass를 수행하게 되면 6, 5, 14, 27, 31의 순서를 가지게 되는데, 31까지 정렬결과를 보장받는다.
          두 번째 pass를 수행하게 되면 5, 6, 14, 27, 31의 순서를 가지게 되는데, 27과 31까지 정렬결과를 보장받는다.
          ...
          총 n-1(n은 배열.length), 4번의 수행 과정이 필요하다.

이를 코드로 작성하면 :

```c
int a[5] = {14, 6, 5, 31, 27};

// i는 반복횟수, j는 배열원소 탐색을 위한 변수
int i, j, l, temp, k;

for (i=0; i<4; i++){
  for (j=0; j<=3-1; j++){
    if (a[j] > a[j+1]){
      temp = a[j];
      a[j] = a[j+1]
      a[j+1] = temp;
    }
  }
  for (k=0; k<4; k++){
    print("%d", a[i]);
  }
}
```


3. Selection Sort
- 첫 번째와 두 번째, 첫 번째와 세 번째, ... , 순서로 데이터를 비교해가면서 정렬을 수행한다.
- 1 pass 수행 후 가장 작은 값을 맨 앞에 배치하고, 다음 pass에서 이 값은 제외하고 수행한다.

이 경우는 버블정렬과 대조적이다. 버블정렬은 맨 끝값이 정렬된 상태를 보장받지만, 선택정렬은 맨 첫값이 정렬된 상태를 보장받는다.
단, 원리상 버블정렬과 수행횟수는 n-1번(n은 원소의 개수)으로 같다.

이를 코드로 나타내면 아래처럼 되는데, 형식이 버블정렬과 매우 비슷하다.

```c
int a[5] = {14, 6, 5, 31, 27};

// i는 반복횟수, j는 배열원소 탐색을 위한 변수
int i, j, l, temp, k;

for (i=0; i<4; i++){
  for (j=i+1; j<5; j++){
    if (a[i] > a[j]){
      temp = a[j];
      a[j] = a[j+1]
      a[j+1] = temp;
    }
  }
  for (k=0; k<4; k++){
    print("%d", a[i]);
  }
}
```



4. Quick Sort

```c
int a[5] = {14, 6, 5, 31, 27};

void q_sort(int sort, int last){
    int i, j, data, temp;
    i = start;
    j = last;
    data = a[start];
    do {
      while (a[i]<=data) {
        i = i + 1;
      }
      
      while (a[i]<=data) {
        j = j - 1;
      }

      if (i < j) {
        a[i] = a[j];
        a[j] = a[i];
      }
    }
    while (i < j) {
      a[j] = a[start];
      a[start] = a[j];
    }
  }

main()
{
  q_sort(start, j-1);
  q_sort(j+1, last);
}



5. Shell Sort
- 일정한 거리(distance 또는 height)만큼 떨어져 있는 데이터와의 비교를 수행한다.
- height = COUNT / 2 + 1(반올림)을 수행하며 height가 1이 되면 마지막 비교를 수행하고 종료한다.
- height가 3보다 크면 height = height / 2 + 1을 수행하고, (타노스)
           3보다 작으면 height = height - 1을 수행한다. (1씩 줄어듬)

코드로 나타내면,

```c
define COUNT 5;
int a[5] = {14, 6, 5, 31, 27};
int h = COUNT / 2 + 1;

main()
{
  int temp, i, j;

  while (h > 0) {
    for (i=h; i<10; i++) {
      j = i - h;
      if (a[k] > a[j + k]) {
        a[j] = a[j+h];
        a[j+h] = a[j];
      }
    }
  }

  if (h > 3){
    h = h/2+1;
  }
  else {
    h - 1;
  }
}