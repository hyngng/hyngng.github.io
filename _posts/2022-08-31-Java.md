---
title:  "자바의 기술적인 부분"

categories:
  - 자바
tags:
  - [자바, Java]

toc: true
toc_sticky: true
 
date: 2022-08-31
last_modified_at: 2022-08-31
---

<h1>주의! 아직 작성중인 글입니다.</h1>

---

<h1>this 키워드</h1>
this 키워드는 키워드가 쓰이고 있는 객체를 지칭하는 키워드이다.  
객체 자기 자신을 지칭하는 것이라고 표현해도 얼추 맞는데, 좀 더 구체적으로는 클래스가 인스턴스화 되었을 때의 자기자신의 메모리 주소를 담는다.

<h1>Super 키워드</h1>
this가 자기 객체 자신을 지칭하는 키워드라면, Super 키워드는 객체가 상속하는 부모 클래스의 객체를 지칭한다. (부모클래스의 또 다른 표현은 슈퍼클래스(SuperClass)인데, Super는 슈퍼클래스의 슈퍼(Super)를 지칭하는 표현이다.)

<h1>final 키워드</h1>
변수의 값을 상수로 고정하는 기능을 수행한다.
(자바스크립트의 const와 유사한 기능을 수행하게 해 준다.)

이게 왜 필요할까? : 3.14와 같은 상수 선언 시 도움이 된다.

-> final도 const도 이 키워드로 선언된 변수 값을 바꾸려 들면 오류가 난다.
-> final로 선언된 class도 선언하려 들면 오류가 난다. (코드를 짠 이에게 final로 선언된 것은 건드릴 수 없음을 알려주는 용도라고 하긴 함)

<h1>클래스 사용</h1>

Main 클래스에서 다른 클래스를 사용하는 한 방법이다.

```
public class Main
{
  int X = 5;
}
```

이 클래스에 대한 객체를 생성해 사용한다.

```
class ClassName {
  public static void main(String[] args)
  {
    Main myObj = new Main();
    System.out.println(myObj.X);
  }
}
```

실행 결과 :
5

<h1>Static || Non-Static(=Public)</h1>
Method can be called without creating object
Static은 오브젝트를 생성하지 않고도 메서드를 호출(Call)할 수 있다.

자바에서 메서드를 만들어 두고 호출하는 방법에 두 가지가 있는데, 하나는 Static, 하나는 Public이다.  
Static로 설정해두면 후에 객체를 생성한 뒤(Ex. Main myObj = new Main()) . 연산자를 통해 클래스 내부의 메서드에 접근해야 한다.(Ex. myObj.function())
Public로 설정해두면 객체를 생성하지 않고 바로 메서드를 호출할 수 있다.(Ex. 바로 function())

-> 내용 바뀐 것 같은데??

<!--알아둬야 하는거 : Static의 단점은 객체지향 설계의 정도를 낮춘다는 것. 그리고 메모리의 효율을 떨어트린다는 것-->

<h1>Constructor</h1>
내용 찾아서 채워놔라 진짜

---

<h1>접근 제한자 (Modifiers)</h1>
Classes, Attributes, Methods, Constructors가 접근할 수 있는 레벨을 설정함.  

<h3>Access Modifiers</h3>
<h3>Non-Access Mldifiers</h3>

<h5>Public</h5>
언제 어디에서든 누구나 접근할 수 있게 하는 키워드  
예를 들어, 이 키워드로 설정되어 있다면 서로 다른 드라이브(C 드라이브 -> D 드라이브)에 위치한 클래스도 문제없이 접근할 수 있다.

<h5>Private</h5>
Attributes, Methods, Constructors가 선언된 해당 클래스에서만 접근할 수 있게 하는 키워드이다.

<h5>Protected</h5>
같은 폴더 내에서만 접근할 수 있게 하는 키워드
드라이버 단위로 아주그냥 여기저기서 마구 접근할 수는 없게, 그러나 같은 가족끼리는 접근할 수 있게 만든다.

+
<h5>Abstract</h5>
세부 디테일 중 중요한 핵심만 남겨 나타내는 것이 "추상"이다.

---

<h1>캡슐화</h1>
-> Attributes, Methods, Constructors를 private로 선언하는 것으로 실현한다.  
"민감한" 정보가 유저에게 전달되지 않게 하기 위해,  
보안을 위해, 코드의 특정 부분만 수정하기 위해 사용한다.  

---

<h1>패키지</h1>
자바의 대표 패키지

- lang (랭귀지)
포함하는 클래스 ex) Math, System...(java.lang.Math 이런 식으로 사용)
- util (유틸리티)
포함하는 클래스 ex) Stack, Scanner...
- net (네트워크)
포함하는 클래스 ex) URL, Socket...
- awt
포함하는 클래스 ex) Panel, Button....
- ...(이 외에도 다수)

패키지는 import java (패키지명) *로 사용한다.
-> java -> 패키지명 -> 특정 클래스||전체(*) 로 step by step 접근하는 방식이다.

자세한 내용은 [여기](https://docs.oracle.com/javase/7/docs/api/overview-summary.html)에서 확인할 수 있다.

<h1>API</h1>
자바 API는 이미 작성된 클래스들의 모음이다.  
말인즉, 패키지도 API이다. API는 만들어진 것을 우리가 사용할 수도 있고, 우리가 만들 수도 있다.(Package 키워드) 

<h1>Inheritance : 클래스 상속</h1>

클래스 상속은 단방향으로 이루어진다. 권위, 계층으로 이해할 수 있다.

- Parent Class : 상속하는 클래스
- Child Class : 상속받는 클래스  

상속을 이용한 클래스 설계 예시)
- Electronics
  - iPhone
    - Mobile Phone
    - Landline
  - Sound Systems
    - Stereos
    - Earphones

상속 형태
- Single (한 클래스가 한 클래스를 상속)
- Multilevel (한 클래스(A)가 한 클래스(B)를 상속, 이 클래스(B)는 또 다른 클래스(C)를 상속)
- Hierachical (여러개의 클래스가 하나의 클래스를 상속)
- Hybrid Inheritance (한 개의 클래스가 두 개의 클래스를 상속, 이 두 클래스는 다시 한 개의 클래스를 상속)

키워드는 "extends"를 이용한다.  
상속받은 클래스는 상속한 클래스의 메서드와 필드를 갖다 쓸 수 있다. (Public으로 선언되어 있는 한)

```
public class Vehicle
{
  ...
}

public class Car extends Vehicle
{
  ...
}
```

이런 식이다. 그런데, ※ C#과 다른 점은 ->

```
public class Vehicle
{
  ...
}

public class Car : Vehicle
{
  ...
}
```

C#에서는 extends의 역할을 :가 대신한다. 키워드가 다르다!



<h1>Polymorphism : 다형성</h1>

Poly : 많은 (Mono, Di, Tri, Tetra... Poly) -> 多
Morphism : 모양, 형태 -> 形性

요약 : 클래스에 의해 선언된 객체가 각 상황에서 다른 메시지를 출력하거나 다른 행동을 취하게끔 만드는 것을 말함.  
이 때 이 클래스는 어떤 클래스를 상속중인 자식클래스여야 함.  
Ex) Shape라는 클래스에서 area()라는 메서드?가 Circle에 대해서는 pi * pow(r, 2) / 2, Triangle에 대해서는 base * height / 2, Rectangle에 대해서는 base * height로 동작하는 것을 "다형성"이라고 함.

***이거임***
B, C 클래스가 A 클래스를 상속한다고 할 때, A에 대한 겉으로는 같은 두 객체를 생성하면서 실제 생성자를 통해 생성하는 것은 그 하위클래스임. 그러면 두 객체는 같은 부모클래스를 통해 생성되었으나 실제로는 하위클래스에 선언된 대로 서로 다르게 동작함. 말이 개 ㅈ같은데 밑에 예시 보면 뭔말인지 알아볼 수 있음. 

```
Animal MyPig = new Pig();
Animal MyDog = new Dog();
```
-> 출력 : MyPig.AnimalSound(); -> 꿀꿀
          MyDog.AnimalSound(); -> 멍멍

<h1>Dates</h1>
자바의 API에서 (java.time을 import하여) LocalDate, LocalTime, LocalDateTime, DateTimeFormatter 등의 클래스를 통해 차례대로 date(yyyy-MM-dd), time(HH-mm-ss-ns), date&&time(yyyy-MM-dd-HH-mm-ss-ns), date-time 객체 등을 얻어낼 수 있다. 終わり。

---

<h1>참고</h1>