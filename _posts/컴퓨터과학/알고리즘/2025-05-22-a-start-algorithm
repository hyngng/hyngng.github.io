---
title: "A* 알고리즘"

categories: [컴퓨터과학, 알고리즘]
tags: [컴퓨터과학, 알고리즘]
start_with_ads: true

toc: true
toc_sticky: true

date: 2025-05-22 00:00:00 +0900
last_modified_at: 2025-05-22 00:00:00 +0900

mermaid: true
math: true
---

A* 알고리즘은 특정 두 지점을 연결하는 최단 경로를 찾기 위한 그래프 탐색 알고리즘입니다. 이 알고리즘 특성은 다음의 한 개 식으로 요약 가능합니다.

$$
f(n) = g(n) + h(n)
$$

## **$g(n)$: 한 칸 이동 비용**

```python

```

## **$h(n)$: 도착지까지의 거리**

$h(n)$은 휴리스틱 측정값을 계산하는 함수입니다. 
해외제품을 구매할 때 환율을 어림잡아 1200~1400원으로 계산하는 것을 어림짐작, 보다 명확한 용어로는 휴리스틱이라고 하는데, 그 휴리스틱입니다.

- 맨해튼 거리 $h(n) = \|x_1 - x_2\| + \|y_1 - y_2\|$ 로는 다음과 같이 구할 수 있습니다.

```python
def heuristic(start_node, end_node):
    return abs(
        end_node[x] - start_node[x]) + abs(end_node[y] - start_node[y]
    )
```

- 유클리드 거리 $h(n) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$ 로는 다음과 같이 구할 수 있습니다.

```python
def heuristic(start_node, end_node):
    return math.sqrt(
        (end_node['x'] - start_node['x'])**2 + (end_node['y'] - start_node['y'])**2
    )
```

## **파이썬 A* 알고리즘 예제**

```python
import heapq

class Node:
    def __init__(self, position, parent=None):
        self.position = position  # (x, y)
        self.parent = parent

        self.g = 0  # 이동 비용
        self.h = 0  # 휴리스틱 비용
        self.f = 0  # 총 비용 = g + h

    def __lt__(self, other):
        return self.f < other.f

def heuristic(a, b):
    # 맨해튼 거리
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def astar(grid, start, end):
    open_list = []
    closed_set = set()

    start_node = Node(start)
    end_node = Node(end)

    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)
        closed_set.add(current_node.position)

        if current_node.position == end_node.position:
            path = []
            while current_node:
                path.append(current_node.position)
                current_node = current_node.parent
            return path[::-1]  # 역순 반환

        x, y = current_node.position
        # 상하좌우 이웃 노드
        neighbors = [(x+dx, y+dy) for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]]

        for next_pos in neighbors:
            nx, ny = next_pos
            if not (0 <= nx < len(grid) and 0 <= ny < len(grid[0])):
                continue  # 격자 밖
            if grid[nx][ny] != 0:
                continue  # 장애물
            if next_pos in closed_set:
                continue

            neighbor = Node(next_pos, current_node)
            neighbor.g = current_node.g + 1
            neighbor.h = heuristic(next_pos, end)
            neighbor.f = neighbor.g + neighbor.h

            # 이미 open_list에 있고 더 나쁜 경로면 스킵
            if any(n.position == neighbor.position and n.f <= neighbor.f for n in open_list):
                continue

            heapq.heappush(open_list, neighbor)

    return None  # 경로 없음

# 예제 격자: 0 = 빈 공간, 1 = 장애물
grid = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 0, 1, 0]
]

start = (0, 0)
end = (4, 4)

path = astar(grid, start, end)
print("경로:", path)
```

```mermaid
block-beta
    columns 5
    0a 1b 0c 0d 0e
    0f 1g 0h 1i 0j
    0k 0l 0m 1n 0o
    1p 1q 0r 0s 0t
    0u 0v 0w 1x 0y

    style 1b fill:#969,stroke:#333;
    style 1g fill:#969,stroke:#333;
    style 1i fill:#969,stroke:#333;
    style 1n fill:#969,stroke:#333;
    style 1p fill:#969,stroke:#333;
    style 1q fill:#969,stroke:#333;
    style 1x fill:#969,stroke:#333;
    
    style 0a fill:#fffa8b,stroke:#666;
    style 0y fill:#fffa8b,stroke:#666;
```

다음과 같이 출력됩니다.

```bash
경로: [(0, 0), (1, 0), (2, 0), (2, 
1), (2, 2), (3, 2), (3, 3), (3, 4), (4, 4)]
```

## **알고리즘 실행**

A* 알고리즘은 실행하면서 인접 노드의 $f(n)$ 비용을 조사합니다. 먼저 `OpenList`에 인접 리스트를 담고, 조사가 끝난 노드는 `ClosedList`로 옮깁니다.