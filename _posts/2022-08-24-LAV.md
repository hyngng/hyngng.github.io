---
title:  "[유니티] LAV-AD 프로젝트"

categories: [프로그래밍, 유니티]
tags: [Unity]

toc: true
toc_sticky: true
 
date: 2022-08-24
last_modified_at: 2023-04-11

img_path: assets/img/[2022_08_24]LAV/
---

<br>

### **<center>코드네임 "TANKE(땅개)"</center>**

<br>
<br>

![LAV-AD_main](https://user-images.githubusercontent.com/96360829/210505297-db1abb36-fe5c-463c-a24c-61c349bf78a2.png){: .shadow }

<br>

![LAV-AD_main2](https://user-images.githubusercontent.com/96360829/231111367-711ce423-a34d-46b4-bd31-fcc6e3f86b8f.png){: .shadow }

<br>

![LAV-AD_main_telephoto (2)](https://user-images.githubusercontent.com/96360829/210505309-6b87adf1-3b3d-41dc-bcc2-a4cb72d9f66e.png){: .shadow }

<br>

![LAV-AD_main_telephoto](https://user-images.githubusercontent.com/96360829/210505313-d1de754b-f0e1-4e98-a1a6-39bfd03a3994.png){: .shadow }

<br>

![LAV-AD_light](https://user-images.githubusercontent.com/96360829/231114066-df8a2b04-3cc0-4339-8d98-a6f39e7cbffe.gif){: .shadow }

<br>

---

<br>

![image](https://user-images.githubusercontent.com/96360829/215330386-4e1f65f2-27e9-4582-856a-74de43852f30.png){: .shadow }

<br>

![LAV-AD_code](https://user-images.githubusercontent.com/96360829/231112934-62cbcc1b-8748-4275-9a2c-c402ed2da2d7.png){: .shadow }

<br>

'LAV-AD' 프로젝트는 2주간 유니티 및 블렌더에 입문하여 진행한 결과물로서 [Tooner](https://www.youtube.com/@tooner/videos)[^1] 유튜브 채널 영상을 통해 키워온 나의 판타지를 실현하기 위해, 그리고 컴퓨터로 가시적인 무언가를 만들어보고자 시작한 프로젝트이다.  

<br>

# 객체 지향과 컴포넌트 기반 설계 입문.

<br>

```cs
public class ClassName : MonoBehaviour
```

<br>

처음에는 객체 지향이 무엇인지 아는 것이 없어 스크립트에 기본 제공되는 첫 줄의 코드부터 당황했던 기억이 난다.

<br>

콘솔에 "Make sure that there are no compile errors and that the file name and class name match."라는 에러 메시지가 있었으므로 파일명과 클래스명이 일치해야 한다는 정도만 알 수 있었고, 예를 들어 `class` 앞의 `public`은 무엇을 의미하는지, `class`가 무엇인지, `ClassName`과 `MonoBehaviour` 사이에 콜론(:)은 왜 있는지, 뒤의 `MonoBehaviour`가 뭔지는 전부 알 수 없었다. 조급한 마음에 그러한 개념들이 있는 이유, 고안된 배경 따위는 눈에 들지조차 않았다.

<br>

컴포넌트에 대한 이해도 없었기 때문에 `Rigidbody`나 `Collider` 등 오브젝트 이동을 구현하기 위한 기본 컴포넌트를 적용하는 단계에서부터 기존 프로그래밍과는 다르다는 괴리감이 있었다. 스크립트를 생성했을 때 그것이 왜 오브젝트의 컴포넌트로 추가되어야 하는지, 코드단에서 오브젝트와 연결하는 개별 코드를 작성하는 것이 정석적인 방법이 아닌지 하는 생각에서였던 것 같다.

<br>

그러나 객체지향은 총알 역할을 하는 Prefab 오브젝트를 인스턴스화하기 시작하면서, 컴포넌트는 서스펜션 구현을 위해 '휠 콜라이더(Wheel Collider)'를 적용하면서부터 차차 이해되고 납득되기 시작했다. 특히 객체지향은 `Instantiate()` 함수를 활용하다보니 "틀과 붕어빵"이라는, 이전까지 깔끔하게 이해되지 않던 비유의 의미와 의도가 빠르게 이해되었다. 말인즉, 좋은 객체지향설계를 위한 조건 중 하나는 적절한 '추상화'임을 알 수 있었다.

<br>

# 블렌더

버텍스와 버텍스를 이어 에지를, 에지와 에지를 이어 페이스를 만들어 내 고유의 모델을 만들고 이를 유니티에 임포트하여 상호작용을 시킨다는 것은 정말 신기한 경험이었다.  
목표로 한 LAV-AD 모델이 두 자릿수의 달러를 지불하지 않으면 쓸만한 모델을 얻을 수 없었으므로 과감히 도전한 블렌더였는데, 몇 가지 기본 단축키 만으로 원하는 3D모델을 구성할 수 있음은 물론 이를 원하는 확장자(.fbx, .3ds, .obj 등)로 빌드해 다른 독립된 프로그램에서 사용한다는 게 정말 강렬한 경험이 되었다.

<br>

그러나 블렌더가 제공한 진가는 인터넷에서 '다른 사람들이 블렌더로 무엇을 만드는가'를 관찰할 동기가 되었다는 것으로, 오늘날 개개인의 판타지를 실현하는 방법에 더 이상 펜과 종이만 놓여있지 않음을 알게 되는 계기가 되었다.[^2] 

<br>

# 이외의 소득

후일담이지만 처음에는 변수의 이름을 지을 때 `intantiated_gameobject`와 같이 언더바(_)를 사용하여 단어 사이를 구분짓는 방식을 사용했다. 파이썬과 C의 영향을 받은 탓이었다. 그런데 다른 사람들이 변수명을 짓는 것을 보면 `instantiatedGameObject`라는 식으로 대소문자를 사용하여 공백 없이 단어와 단어 사이를 구분짓는 것이었다. 심지어는 `_instantiatedGameObject`처럼 변수명 앞에 언더바를 붙이는 경우도 많았다!  
다른 사람이 작성한 코드를 읽고 복사해 가져오는 과정이 반복되다보니 이 방식이 마음에 들게 되었고, 굉장히 자연스럽게 차용하게 되었다. 심지어는 일반 파일명을 지을 때, 과제 제출을 위한 파일명을 작성할 때에도 애용했다. 그것이 파스칼케이스 혹은 카멜케이스, 그리고 언더스코어라는 전용 이름이 있을 정도로 방식이 이미 잘 정립되어 있었음을 알게 되는 것은 나중의 일이다.

<br>

결과적으로는 일종의 기념비적인 터닝포인트가 되었다. 이론만으로 남아있던 프로그래밍 개념을 내재화하는 동기를 제공했을뿐만 아니라 내 스스로 세부적인 인과관계를 더 잘 이해하기 위해 정보를 찾고 고민하는 첫경험이 되었고, 특히 객체지향 설계를 접하면서 스크립트간의 계층과 독립성 구현에 집중하며 보다 크고 이상적인 시스템을 상상하는 계기가 되었다.  

<br>

2023.04.11<br>
종래의 전통적인 구글링만으로 맨땅에 헤딩하듯이 비결을 알아내는 시대가 저물고 인공지능을 이용해 효율적으로 탐색하는 시대가 온 오늘날, 그러한 경험의 사실상의 막차를 탔다는 것에 대해 미묘한 감정이 있다.  
"좀 더 일찍 등장하지" 싶으면서도 시대가 변화하고 있음을 느끼고 기술발전에 관심을 가지는 계기가 되었음을 생각하면 위안이 된다.

<br>

---
[^1]: 배틀그라운드 초기 개발팀 일원 중 한 명이 되었다.
[^2]: 정말, 근미래의 언젠가에 제대로 배우고 싶다.