---
title:  "[유니티] LAV-AD 프로젝트"

categories: [프로그래밍, 유니티]
tags: [Unity]

toc: true
toc_sticky: true
 
date: 2022-08-24
last_modified_at: 2023-04-11

img_path: assets/img/[2022_08_24]LAV/
---

<br>

### **<center>코드네임 "TANKE(땅개)"</center>**

<br>
<br>

![LAV-AD_main](https://user-images.githubusercontent.com/96360829/210505297-db1abb36-fe5c-463c-a24c-61c349bf78a2.png){: .shadow }

<br>

![LAV-AD_main2](https://user-images.githubusercontent.com/96360829/231111367-711ce423-a34d-46b4-bd31-fcc6e3f86b8f.png){: .shadow }

<br>

![LAV-AD_main_telephoto (2)](https://user-images.githubusercontent.com/96360829/210505309-6b87adf1-3b3d-41dc-bcc2-a4cb72d9f66e.png){: .shadow }

<br>

![LAV-AD_main_telephoto](https://user-images.githubusercontent.com/96360829/210505313-d1de754b-f0e1-4e98-a1a6-39bfd03a3994.png){: .shadow }

<br>

![LAV-AD_light](https://user-images.githubusercontent.com/96360829/231114066-df8a2b04-3cc0-4339-8d98-a6f39e7cbffe.gif){: .shadow }

<br>

---

<br>

![image](https://user-images.githubusercontent.com/96360829/215330386-4e1f65f2-27e9-4582-856a-74de43852f30.png){: .shadow }

<br>

![LAV-AD_code](https://user-images.githubusercontent.com/96360829/231112934-62cbcc1b-8748-4275-9a2c-c402ed2da2d7.png){: .shadow }

<br>

'LAV-AD' 프로젝트는 2주간 유니티 및 블렌더에 입문하여 진행한 결과물로서 [Tooner](https://www.youtube.com/@tooner/videos)[^2^][1] 유튜브 채널 영상을 통해 키워온 나의 판타지를 실현하기 위해, 그리고 컴퓨터로 가시적인 무언가를 만들어보고자 시작한 프로젝트이다.  

<br>

이 프로젝트는  이론만으로 남아있었던 프로그래밍 개념에 직접 상호작용하는 경험이 되었다. 특히, 처음엔 당황스러웠던 객체지향 설계에 익숙해지면서 흥미를 붙이는 계기가 되었다.  

<br>

---

<br>

# 객체 지향 시작하기.

<br>

```cs
public class ClassName : MonoBehaviour
```

<br>

C#이라는 새 언어를 탐색하기 이전에 객체 지향 프로그래밍이 무엇인지 아는 것이 전혀 없어 첫 줄의 코드부터 당황했던 기억이 난다. 고등학교때까지 정말 얕디 얕은 아두이노와 파이썬밖에 모르고 있었던 나에게 이해할 수 있는 것이 없었다.

<br>

`Make sure that there are no compile errors and that the file name and class name match.` 에러 메시지가 있었으므로 파일명과 클래스명은 일치해야 한다는 정도는 이해할 수 있었다. 그러나 예를 들어 `class` 앞의 `public`은 무엇을 의미하는지, `class`가 무엇인지, `ClassName`과 `MonoBehaviour` 사이에 콜론(:)은 왜 있는지, 뒤의 `MonoBehaviour`가 뭔지는 전부 알 수 없었다. 조급한 마음에 그러한 개념들이 있는 이유, 고안된 배경 따위는 눈에 들지조차 않았던 것 같다.

<br>

그러나 총알 역할을 하기 위한 게임 오브젝트를 Prefab으로 세부속성을 고정시키고 인스턴스화를 통해 활용하기 시작하면서부터 차차 이해되기 시작했다. `Instantiate()` 함수를 활용하기 시작하면서 "틀과 붕어빵"이라는, 이전까지 깔끔하게 이해되지 않던 비유의 의미와 의도를 빠르게 이해하게 되었다.

<br>

# 컴포넌트 기반 설계 (Component-based design) 적응하기.

<br>

컴포넌트에 대한 이해도 없었기 때문에 스크립트를 생성했을 때 그것이 왜 컴포넌트로 추가되어야 하는지 이해할 수 없었다. 오히려 코드단에서 오브젝트와 연결하는 개별 코드를 작성하는 것이 정석적이지 않나 하는 의문이 있었다.

<br>

때문에 `Rigidbody`나 `Collider` 등 오브젝트 이동을 구현하기 위한 기본 컴포넌트를 적용하는 단계에서부터 기존 프로그래밍과는 다르다는 괴리감이 있었다. 즉각적인 비주얼 피드백이 있었기에 체감 허들이 그나마 낮게 느껴진 것이지 만약 콘솔창과만 상호작용을 해야 하는 정석적인 프로그램이었다면 금세 질렸을 거라고 생각한다.

<br>

그러나 객체지향의 단초를 총알 오브젝트의 인스턴스화를 통해 빠르게 이해하게 되었다면, 컴포넌트의 경우 컴포넌트를 지우고 추가하고 개별 값을 세세하게 설정해보면서 어느정도 감을 잡다가 서스펜션 구현을 위한 공식 특수 마찰 모델, '휠 콜라이더(Wheel Collider)'을 통해 대부분의 큼지막한 기능이 컴포넌트를 통해 구현되고 있음을 발견하면서 이해하게 되었다.

<br>

# 블렌더

버텍스와 버텍스를 이어 에지를 만들고, 다시 에지와 에지를 이어 페이스를 만들어 내 고유의 모델을 만들어 상호작용을 시킨다는 것은 정말 특별한 경험이었다.  
목표로 한 LAV-AD 모델이 두 자릿수의 달러를 지불하지 않으면 쓸만한 모델을 얻을 수 없었으므로 과감히 도전한 블렌더였는데, 몇 가지 기본 단축키 만으로 원하는 3D모델을 구성할 수 있음은 물론 이를 원하는 확장자(.fbx, .3ds, .obj 등)로 빌드해 다른 독립된 프로그램에서 사용한다는 게 정말 강렬한 경험이 되었다.  
그러나 블렌더가 제공한 진가는 인터넷에서 '다른 사람들이 블렌더로 무엇을 만드는가'를 관찰할 동기가 되었다는 것으로, 오늘날 개개인의 판타지를 실현하는 방법에 더 이상 펜과 종이만 놓여있지 않음을 알게 되는 계기가 되었다. 정말, 근미래의 언젠가에 제대로 배워 다시 시도해보고 싶다.  

# 이외의 소득

<br>

후일담이지만 처음에는 변수의 이름을 지을 때 `intantiated_gameobject`와 같이 언더바(_)를 사용하여 단어 사이를 구분짓는 방식을 사용했다. 파이썬과 C의 영향을 받은 탓이었다. 그런데 다른 사람들이 변수명을 짓는 것을 보면 `instantiatedGameObject`라는 식으로 대소문자를 사용하여 공백 없이 단어와 단어 사이를 구분짓는 것이었다. 심지어는 `_instantiatedGameObject`처럼 변수명 앞에 언더바를 붙이는 경우도 많았다!  
다른 사람이 작성한 코드를 읽고 복사해 가져오는 과정이 반복되다보니 이 방식이 마음에 들게 되었고, 굉장히 자연스럽게 차용하게 되었다. 심지어는 일반 파일명을 지을 때, 과제 제출을 위한 파일명을 작성할 때에도 애용했다. 그것이 파스칼케이스 혹은 카멜케이스, 그리고 언더스코어라는 전용 이름이 있을 정도로 방식이 이미 잘 정립되어 있었음을 알게 되는 것은 나중의 일이다.

<br>

2023.04.11<br>
종래의 전통적인 구글링만으로 맨땅에 헤딩하듯이 비결을 알아내는 시대가 저물고 인공지능을 이용해 효율적으로 탐색하는 시대가 온 오늘날, 그러한 경험의 사실상의 막차를 탔다는 것에 대해 미묘한 감정이 있다.  
"좀 더 일찍 등장하지" 싶으면서도 시대가 변화하고 있음을 느끼고 기술발전에 관심을 가지는 계기가 되었음을 생각하면 그것은 적절한 보상이라는 생각이 든다.

---

[^2^][1]: 배틀그라운드 개발팀 일원 중 한 명이다.