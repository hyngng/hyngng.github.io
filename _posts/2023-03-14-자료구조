---
title:  "자료구조"

categories:
  - 프로그래밍
tags:
  - [자료구조]

toc: true
toc_sticky: true
 
date: 2023-03-14
last_modified_at: 2023-03-14
---

<br/>

# 아직 작성중인 글

<br/>

- 데이터 : 현실세계에서 관측되는 값 또는 사실

<br/>

- 데이터의 표현 단위
    - bit  : 정보표현의 최소단위
    - byte : 8비트 → 맨 앞과 맨 뒤 이름
      - ASCII CODE : 중형 PC에서의 데이터 통신용
        - 약자 :
        - 7bit 데이터 사용 : 숫자(10), 문자(52), 특수문자(30)개를 모두 표현하기 위해 2^7(=128)의 가짓수만 필요하기 때문
      - EBCICD : 대형 PC or IBM 기종에서의 데이터 통신용
        - 약자 :
        - 8bit 데이터 사용
      - UNICODE : 한글, 그리스 알파벳, 히라가나&가타가나, 한자, 키릴 문자, 만주 문자 등의 전세계 문자가 할당됨
        - 16bit 데이터 사용 : 2^16 = 65536, 24자 한글로만 11172가짓수 조합이 가능하고, 약 30000만여개의 실용한자가 존재하기 때문
    - field(= item) : 연관된 문자의 모임
      - 예를 들어, 행렬 데이터는 여러개의 필드로 구성된다.
    - record : 연관된 항목의 모임
      - 예를 들어, 행렬 데이터 중 행 하나하나는 관점에 따라 레코드로 볼 수 있다.
    - file : 연관된 record의 모임 or 보조기억장치의 연속적인 영역이 존재하는 문자열의 모임으로서 논리적인 한 단위로 취급되는 것 
      - 예를 들어, 행렬 데이터 자체를 레코드의 모임으로서 하나의 파일로 볼 수 있다.
    - Data Base : 연관된 파일의 모임

    데이터 통신업계의 코드 : 표준 코드 (아스키, 유니...)

    정수와 실수 등이 컴퓨터 내에서 어떻게 표현되는지

<br/>

  - 컴퓨터의 소수 표현
  
    십진법 실수를 이진법으로 표현하기 -> 이론상 0.75 = 0.5(= 2^-1) + 0.25(= 2^-2)로 표현되므로, 0.75는 이진법으로 나타내면 '0.11'
    -> 이 경우 0.3 등은 0.11111....로 무한히 이어져야 함

    - 고정소수점
      - 정수 표현 비트수와 소수 표현 비트수를 할당
    - 부동소수점
      - 


<!--메모-->
2진정수 - 2's complement(보수)가 가장 많이 쓰임(signed magnitude, 1's complement 등)
  -> 부호와절대값(signed magnitude)
    -> 양수표현방법 : 8비트 중 가장 앞자리(=sign) 값이 0이면 양수, 1이면 음수.
      -> 표현할 수 있는 정수의 범위가 할당되는 비트의 수에 비례함. (Ex. 8비트 -> 2^7 - 1 부터 2^7 + 1까지 표현됨, 제곱수가 8이 아닌 7인 이유는 한 비트가 부호표현에 할당되었기 때문)
    -> 보수
      -> 2의 보수는 1의 보수에 +1
      -> 2의 보수의 표현 범위는 -(2^(n-1)) ~ +(2^(n-1)-1)로, 부호와절대값이나 1의보수보다 '1' 더 많다.
10진정수 -> IBM 대형컴퓨터(가 EBCDIC 코드를 사용하기 때문)에서 사용
  -> PACK : 연산가능이지만 출력이 불가
    -> F1, F2, F3
  -> UNPACK(ZONE) : 연산이 불가하지만 출력가능
    -> 12, 3F
    -> 양수는 A, C, E, F / 음수는 B, D를 사용
실수 -> 128 bias가 가장 많이 쓰임
  -> 64 bias : 16진수로 구성됨
    -> 16진수화 : Noamalization(정규화)라고 부름 -> 소숫점 뒤에 0이 아닌 유효숫자가 나오도록 구성한다.
    -> 지수와 가수
  -> 128 bias : 2진수로 구성됨
    -> Normalization 거침
    -> 
  -> 127 bias : 2진수로 구성됨
    -> Normalization 거침 -> 소숫점 앞에 유효숫자가 옴
    -> 
  -> 128 bias와 127 bias의 지수분은 다르고 가수분은 같음.

컴퓨터에서 ->
정수 : fixed point number
실수 : floating point number -> 숫자 사이에서 포인트(.)가 부유(float)해서.

- 2진수 변환

<br/>

# linear, 선형구조 (배열)

- Queue
- Stack
- Deque

<br/>

# Non-linear, 비선형구조

- Tree
- Graph

<br/>

---

03/21 : 알고리즘

# 알고리즘 (PDL이라고도 표현 -> Program Design Language): 문제를 해결하기 위한 단계적인 절차와 과정, Or, 명령의 집합.
  - 알고리즘의 작성 pseudo code를 사용한다.
  - 알고리즘은 입력, 출력, 명확성, 유한성, 실제성의 조건을 만족한다.
  - 알고리즘의 분석을 위해 Time complexity(시간복잡도)와 space complexity를 사용한다.
  - 시간복잡도는 특정 문제 해결을 위한 연산의 빈도수를 차수(degree)로 표현함.
  - O(1), O(log n), O(n), O(nlog n), O(n^2), O(2^n), O(n^m), O(N!) 등으로 표현한다.
  - Big O 표시법은 연산 차수가 가장 높은 것을 알고리즘 계산 차수로 사용한다. : 시간복잡도의 상한
    - f(n) = O(g(n))꼴로 나타냄
  - 옴(Ω) 표시법은 연산차수가 가장 낮은 것을 알고리즘 계산 차수로 사용한다. : 시간복잡도의 하한
    - f(n) = Ω(g(n))꼴로 나타냄
  - Big O 표시법과 Ω 표시법은 교집합이 되는 표시법을 Θ-표시법으로 나타내며, <<최적 알고리즘>>으로 사용한다.

  - 알고리즘 -> 디자인 단계에서 작성(조용재)
  
  - 참고사항 : 순서도, UML (-> PDL의 대표적 예시로서, "의사코드"라고 부름)

03/22 : ??

# 순서 리스트
- Segmential list, linear list : 순서 리스트는 데이터가 연속적으로 기억 장치에 저장 및 처리되는 구조 
  - A = {a1, a2, a3, a4, a5...}
- 배열(Array)
  - 배열명은 주솟값을 가진다.
  - 연속적으로 배치된 기억장소의 형태이며, index와 값을 mapping한다.
  - 연속적인 기억장소에 1개의 블록으로 존재한다.
  - 2개 이상의 변수가 공통적인 성질을 가지고. 하나의 변수와 첨자를 이용한다.
  - 배열이 사용되는 언어에 따라 행중심(row oriented)과 열중심(column oriented) 배열로 구분한다.

- 첨자와 인덱스 : 첨자는 ['0'], ['1'], ['2'], 인덱스는 'k[0]' 그 자체.

int k[3] = {10, 20, 30};일 때,
k[0]의 값은 10이고 주솟값은 예를 들어 1000.
k[1]의 값은 20이고 주솟값은 1004.
k[2]의 값은 30이고 주솟값은 1008. (물론, 주솟값은 16비트로 표현될 것이다...?)

```c
for (i=0; i<3; i++){
  print("%d %p \n", %k[0], %k[0]);
}
```

- 2차원, 3차원 배열도 결국엔 1차원 순서로 나타낼 수 있다.

- 2차원, 3차원 배열 해두셈!
  - 2차원 배역 => "행렬렬"
  - 3차원 배열 => (면, 행, 열) 순서. 교수님 기준으로는 나와 가까운 면이 '1'면임.

- 3차원 배열 (u1, u2, u3)에서 특정위치 (i1, i2, i3)의 위치는 : location = i1*u2*u3 + i2*u3 + i3

- 면 : page
  행 : row
  열 : column

- 구조체, 문자열

---

3월 28일 

- *** 인덱스가 0이 아닌 1부터 시작하는 경우 ***

  - (2차원 배열의 경우)
    - 행 중심 : (1, 1)다음이 (1, 2).
    - 열 중심 : (1, 1)다음이 (2, 1).
    -> 배열의 크기가 (m, n)일 경우, 특정위치 (i, j)는 :
      - 행 중심일 경우 : n(i - 1) + j,
      - 열 중심일 경우 : m(j - 1) + i가 된다.

  - (3차원 배열의 경우)
    -> 배열의 크기가 (p, m, n)일 경우, 특정위치 (k, i, j)는 :
    - 행 중심 : m * n (k - 1) + n (i - 1) + j
    - 열 중심 : m * n (k - 1) + m (j - 1) + i

-> 배우는 이유 : C언어는 행 중심, 0부터 시작하는 언어지만 타 언어의 경우 열 중심, 1부터 시작하는 언어일 수도 있기 때문



* Spaese matrix(희소 행렬)
  - 2차원 배열에서 공집합(= 0)인 요소가 대부분을 차지하는 경우, 즉 공집합(= 0)이 아닌 요소가 매우 적은 행렬.
  - 공집합(= 0)이 아닌 요소를 별도로 저장하면 원래 행렬보다 기억장소를 50% 이상 절약!! 할 수 있다.

  희소행렬 예시) int sparse[8][8] = {{0, 0, 0, 0, 0, 6, 0, 0},
                                    {0, 0, 0, 14, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 5, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 0, 0},
                                    {0, 0, 2, 0, 0, 0, 0, 0},
                                    {0, 0, 0, 3, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 7, 0}}

  희소행렬 활용 예제 => 찾아보기
    - 중첩 for문을 이용해 일반 행렬로 변환하여 출력해서 사용...? => 왜 메모리가 절약

---

3월 28일

  - 구조체 : "레코드"의 일종이다.

    - 예시
      ```c
      struct list {
        char name[15]; -> 15바이트 할당
        int no;        -> 디폴트 4바이트 할당
      }

      ```c
      int main()
      {
        struct list k;
        k.name = "kim";

        struct list k[3];
      }
  
      ```c
      int k = 31;
      int *p, **pp;

      p = &k;
      pp = &p;

      k += 1;
      (*p)++;
      (*pp)++;

      print("k = #d", k);
      ```
      -> 출력 결과 : k = 31에 1이 총 3번
         (예를)
         더해져서 34가 출력된다.

      ```c
      char k[5] = "ab";
      char *k1 = "cd";

      print("%s %s\n", k, k1);
      ```
      -> k는 배열의 이름 자체가 주솟값을 가지기 때문에, *를 붙일 필요가 없음.



  - String

    - char k[5] = "ab";  -> {'a', 'b', 'null', 'null', 'null'}으로 저장됨
    - char k[5] = {'a', 'b', 'null', 'null', 'null'}; -> 위와 같은 의미의 다른 표현.

    - char *str = "com"  -> 저장소에 'c', 'o', 'm', 'null' 런 식으로 저장됨
    - print("%s %s \n", k, str+2);로 실행해 볼것.

  - *포인터 배열*
    - char *str[3] = {"ab", "cd", "ef"};

---
## <b>참고</b>