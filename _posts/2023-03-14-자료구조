---
title:  "자료구조"

categories:
  - 프로그래밍
tags:
  - [자료구조]

toc: true
toc_sticky: true
 
date: 2023-03-14
last_modified_at: 2023-03-14
---

<br/>

# 아직 작성중인 글

<br/>

- 데이터 : 현실세계에서 관측되는 값 또는 사실

<br/>

- 데이터의 표현 단위
    - bit  : 정보표현의 최소단위
    - byte : 8비트 → 맨 앞과 맨 뒤 이름
      - ASCII CODE : 중형 PC에서의 데이터 통신용
        - 약자 :
        - 7bit 데이터 사용 : 숫자(10), 문자(52), 특수문자(30)개를 모두 표현하기 위해 2^7(=128)의 가짓수만 필요하기 때문
      - EBCICD : 대형 PC or IBM 기종에서의 데이터 통신용
        - 약자 :
        - 8bit 데이터 사용
      - UNICODE : 한글, 그리스 알파벳, 히라가나&가타가나, 한자, 키릴 문자, 만주 문자 등의 전세계 문자가 할당됨
        - 16bit 데이터 사용 : 2^16 = 65536, 24자 한글로만 11172가짓수 조합이 가능하고, 약 30000만여개의 실용한자가 존재하기 때문
    - field(= item) : 연관된 문자의 모임
      - 예를 들어, 행렬 데이터는 여러개의 필드로 구성된다.
    - record : 연관된 항목의 모임
      - 예를 들어, 행렬 데이터 중 행 하나하나는 관점에 따라 레코드로 볼 수 있다.
    - file : 연관된 record의 모임 or 보조기억장치의 연속적인 영역이 존재하는 문자열의 모임으로서 논리적인 한 단위로 취급되는 것 
      - 예를 들어, 행렬 데이터 자체를 레코드의 모임으로서 하나의 파일로 볼 수 있다.
    - Data Base : 연관된 파일의 모임

    데이터 통신업계의 코드 : 표준 코드 (아스키, 유니...)

    정수와 실수 등이 컴퓨터 내에서 어떻게 표현되는지

<br/>

  - 컴퓨터의 소수 표현
  
    십진법 실수를 이진법으로 표현하기 -> 이론상 0.75 = 0.5(= 2^-1) + 0.25(= 2^-2)로 표현되므로, 0.75는 이진법으로 나타내면 '0.11'
    -> 이 경우 0.3 등은 0.11111....로 무한히 이어져야 함

    - 고정소수점
      - 정수 표현 비트수와 소수 표현 비트수를 할당
    - 부동소수점
      - 


<!--메모-->
2진정수 - 2's complement(보수)가 가장 많이 쓰임(signed magnitude, 1's complement 등)
  -> 부호와절대값(signed magnitude)
    -> 양수표현방법 : 8비트 중 가장 앞자리(=sign) 값이 0이면 양수, 1이면 음수.
      -> 표현할 수 있는 정수의 범위가 할당되는 비트의 수에 비례함. (Ex. 8비트 -> 2^7 - 1 부터 2^7 + 1까지 표현됨, 제곱수가 8이 아닌 7인 이유는 한 비트가 부호표현에 할당되었기 때문)
    -> 보수
      -> 2의 보수는 1의 보수에 +1
      -> 2의 보수의 표현 범위는 -(2^(n-1)) ~ +(2^(n-1)-1)로, 부호와절대값이나 1의보수보다 '1' 더 많다.
10진정수 -> IBM 대형컴퓨터(가 EBCDIC 코드를 사용하기 때문)에서 사용
  -> PACK : 연산가능이지만 출력이 불가
    -> F1, F2, F3
  -> UNPACK(ZONE) : 연산이 불가하지만 출력가능
    -> 12, 3F
    -> 양수는 A, C, E, F / 음수는 B, D를 사용
실수 -> 128 bias가 가장 많이 쓰임
  -> 64 bias : 16진수로 구성됨
    -> 16진수화 : Noamalization(정규화)라고 부름 -> 소숫점 뒤에 0이 아닌 유효숫자가 나오도록 구성한다.
    -> 지수와 가수
  -> 128 bias : 2진수로 구성됨
    -> Normalization 거침
    -> 
  -> 127 bias : 2진수로 구성됨
    -> Normalization 거침 -> 소숫점 앞에 유효숫자가 옴
    -> 
  -> 128 bias와 127 bias의 지수분은 다르고 가수분은 같음.

컴퓨터에서 ->
정수 : fixed point number
실수 : floating point number -> 숫자 사이에서 포인트(.)가 부유(float)해서.

- 2진수 변환

<br/>

# linear, 선형구조 (배열)

- Queue
- Stack
- Deque

<br/>

# Non-linear, 비선형구조

- Tree
- Graph

<br/>

---

03/21 : 알고리즘

# 알고리즘 (PDL이라고도 표현 -> Program Design Language): 문제를 해결하기 위한 단계적인 절차와 과정, Or, 명령의 집합.
  - 알고리즘의 작성 pseudo code를 사용한다.
  - 알고리즘은 입력, 출력, 명확성, 유한성, 실제성의 조건을 만족한다.
  - 알고리즘의 분석을 위해 Time complexity(시간복잡도)와 space complexity를 사용한다.
  - 시간복잡도는 특정 문제 해결을 위한 연산의 빈도수를 차수(degree)로 표현함.
  - O(1), O(log n), O(n), O(nlog n), O(n^2), O(2^n), O(n^m), O(N!) 등으로 표현한다.
  - Big O 표시법은 연산 차수가 가장 높은 것을 알고리즘 계산 차수로 사용한다. : 시간복잡도의 상한
    - f(n) = O(g(n))꼴로 나타냄
  - 옴(Ω) 표시법은 연산차수가 가장 낮은 것을 알고리즘 계산 차수로 사용한다. : 시간복잡도의 하한
    - f(n) = Ω(g(n))꼴로 나타냄
  - Big O 표시법과 Ω 표시법은 교집합이 되는 표시법을 Θ-표시법으로 나타내며, <<최적 알고리즘>>으로 사용한다.

  - 알고리즘 -> 디자인 단계에서 작성(조용재)
  
  - 참고사항 : 순서도, UML (-> PDL의 대표적 예시로서, "의사코드"라고 부름)

03/22 : ??

# 순서 리스트
- Segmential list, linear list : 순서 리스트는 데이터가 연속적으로 기억 장치에 저장 및 처리되는 구조 
  - A = {a1, a2, a3, a4, a5...}
- 배열(Array)
  - 배열명은 주솟값을 가진다.
  - 연속적으로 배치된 기억장소의 형태이며, index와 값을 mapping한다.
  - 연속적인 기억장소에 1개의 블록으로 존재한다.
  - 2개 이상의 변수가 공통적인 성질을 가지고. 하나의 변수와 첨자를 이용한다.
  - 배열이 사용되는 언어에 따라 행중심(row oriented)과 열중심(column oriented) 배열로 구분한다.

- 첨자와 인덱스 : 첨자는 ['0'], ['1'], ['2'], 인덱스는 'k[0]' 그 자체.

int k[3] = {10, 20, 30};일 때,
k[0]의 값은 10이고 주솟값은 예를 들어 1000.
k[1]의 값은 20이고 주솟값은 1004.
k[2]의 값은 30이고 주솟값은 1008. (물론, 주솟값은 16비트로 표현될 것이다...?)

```c
for (i=0; i<3; i++){
  print("%d %p \n", %k[0], %k[0]);
}
```

- 2차원, 3차원 배열도 결국엔 1차원 순서로 나타낼 수 있다.

- 2차원, 3차원 배열 해두셈!
  - 2차원 배역 => "행렬렬"
  - 3차원 배열 => (면, 행, 열) 순서. 교수님 기준으로는 나와 가까운 면이 '1'면임.

- 3차원 배열 (u1, u2, u3)에서 특정위치 (i1, i2, i3)의 위치는 : location = i1*u2*u3 + i2*u3 + i3

- 면 : page
  행 : row
  열 : column

- 구조체, 문자열

---

3월 28일 

- *** 인덱스가 0이 아닌 1부터 시작하는 경우 ***

  - (2차원 배열의 경우)
    - 행 중심 : (1, 1)다음이 (1, 2).
    - 열 중심 : (1, 1)다음이 (2, 1).
    -> 배열의 크기가 (m, n)일 경우, 특정위치 (i, j)는 :
      - 행 중심일 경우 : n(i - 1) + j,
      - 열 중심일 경우 : m(j - 1) + i가 된다.

  - (3차원 배열의 경우)
    -> 배열의 크기가 (p, m, n)일 경우, 특정위치 (k, i, j)는 :
    - 행 중심 : m * n (k - 1) + n (i - 1) + j
    - 열 중심 : m * n (k - 1) + m (j - 1) + i

-> 배우는 이유 : C언어는 행 중심, 0부터 시작하는 언어지만 타 언어의 경우 열 중심, 1부터 시작하는 언어일 수도 있기 때문



* Spaese matrix(희소 행렬)
  - 2차원 배열에서 공집합(= 0)인 요소가 대부분을 차지하는 경우, 즉 공집합(= 0)이 아닌 요소가 매우 적은 행렬.
  - 공집합(= 0)이 아닌 요소를 별도로 저장하면 원래 행렬보다 기억장소를 50% 이상 절약!! 할 수 있다.

  희소행렬 예시) int sparse[8][8] = {{0, 0, 0, 0, 0, 6, 0, 0},
                                    {0, 0, 0, 14, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 5, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 0, 0},
                                    {0, 0, 2, 0, 0, 0, 0, 0},
                                    {0, 0, 0, 3, 0, 0, 0, 0},
                                    {0, 0, 0, 0, 0, 0, 7, 0}}

  희소행렬 활용 예제 => 찾아보기
    - 중첩 for문을 이용해 일반 행렬로 변환하여 출력해서 사용...? => 왜 메모리가 절약

---

3월 28일

  - 구조체 : "레코드"의 일종이다.

    - 예시
      ```c
      struct list {
        char name[15]; -> 15바이트 할당
        int no;        -> 디폴트 4바이트 할당
      }

      ```c
      int main()
      {
        struct list k;
        k.name = "kim";

        struct list k[3];
      }
  
      ```c
      int k = 31;
      int *p, **pp;

      p = &k;
      pp = &p;

      k += 1;
      (*p)++;
      (*pp)++;

      print("k = #d", k);
      ```
      -> 출력 결과 : k = 31에 1이 총 3번
         (예를)
         더해져서 34가 출력된다.

      ```c
      char k[5] = "ab";
      char *k1 = "cd";

      print("%s %s\n", k, k1);
      ```
      -> k는 배열의 이름 자체가 주솟값을 가지기 때문에, *를 붙일 필요가 없음.



  - String

    - char k[5] = "ab";  -> {'a', 'b', 'null', 'null', 'null'}으로 저장됨
    - char k[5] = {'a', 'b', 'null', 'null', 'null'}; -> 위와 같은 의미의 다른 표현.

    - char *str = "com"  -> 저장소에 'c', 'o', 'm', 'null' 런 식으로 저장됨
    - print("%s %s \n", k, str+2);로 실행해 볼것.

  - *포인터 배열*
    - char *str[3] = {"ab", "cd", "ef"};

---


4월 4일

- %p, %s

- stdio.h에 선언되어 있는 puts, putchar 함수?

```c
//print("k[0] 주소 : %p" &k[d])

int main()
{
  char *k[3] = {"ab", "cd", "efg"}; // 각 배열 요소마다 e, f, g, >null< 기준으로 4바이트씩 메모리가 확보됨, 가장 긴 요소를 기준으로 확보되기 때문에 모두 4바이트씩 지정된다.
  char *p1, *p2, *p3;

  p1 = k[0];
  p2 = k[1];
  p3 = k[2];

  printf("%p \n" p1);
  printf("%p \n" p2);
  printf("%p \n" p3);
}

// 혹은,

printf("%s \n", p1);
puts(p2);
while(*p3 != i0(->null?));
  putchar(*p3++);
return 0;
```

- #include <string.h>에 대해서
  - null을 포함하지 않는 길이를 반환하는 함수 포함함
  - 콜리지
  - cpy
  - str 캣



- 선형 리스트, linear list OR Segmential list, -> 주로 배열을 이용하여 사용하게 된다 : 순서를 가진다는 것이 핵심이다.
  - 기억장소에 연속적으로 저장되며, 원소 (atom, node | 부연설명 : 데이터를 노드, 아톰으로 표현함.)들간에 "순서"를 가지는 리스트임.
  - 기억 장소 활용도가 좋으며, 자주 변경되지 않는 데이터임.
  - 저장에 유리함.
  - 여분의 기억공간이 확보되어 있지 않으면 데이터를 추가할 수 없으며, 추가와 삭제시 많은 데이터의 이동이 필요함. -> 처음에 정의한 배열의 크기대로 굴러가게 됨.
  - n개의 데이터에서 k번째 데이터 추가시 (n - k + 1)번의 데이터 이동이 필요하며, 데이터 삭제시 (n - k)번의 데이터 이동이 필요함.
    - 추가시 평균 이동 횟수 = (1/n) * (n)E(k=1){n - k + 1} (*E -> 시그마)
      - 왜? Ex.
        1. [5, 6, 14, 27, 31]에 15를 추가하고 싶다면,
        2. [5, 6, 14,   , 27, 31]처럼 뒤 2개를 이동시키고,
        3. [5, 6, 14, 15, 27, 31]처럼 15를 적절한 순서에 맞추어 데이터를 넣어야 할 것이다.
        4. 이 때 이동 횟수는 5 - 4 + 1 = '2'가 될 것.
    - 삭제시 평균 이동 횟수 = (1/n) * (n)E(k=1){n - k}
      - 왜? Ex.
        1. [5, 6, 14, 15, 27, 31]에서 6을 삭제하고 싶다면,
        2. [5, 14, 15, 27, 31]처럼 뒤 4개 데이터가 순서를 이동해야 할 것이다.
        3. 이 때 이동 횟수는 6 - 2 = '4'가 될 것.

- 링크드 리스트, linked list
  - 처리할 데이터의 포인터를 가지는 리스트이다.
  - 기억장소에 데이터가 연속적으로 저장되어 있지 않아도 포인터를 이용하여 처리가 가능하다.(->장점)
  - 그러나 포인터 값으로 인한 기억장소의 낭비와 처음부터 데이터를 탐색해야 하는 단점이 있다.
    - 예시
    ```c
    struct list {
      char name[10];
      int no;
      struct list *link; -> 포인터
    }
  - 구조 : |data|pointer|
  - 추가 Algorithm |---|P(i)| -x-> |---|P(i+1)|
                        ㄴ-->|---|P(new)-->           (그냥 새로 추가하면 됨.)
    - 새로운 노드의 생성 -> 기억장소를 할당 -> malloc() 함수를 통해 해결 (memory allocate)
  - 삭제 Algorithn |---|P(i-1)| -> |---|P(i)|         (그냥 바로 삭제하면 됨.)
    - 노드의 삭제 -> 기억장소를 해제 -> free()

    단, 위의 malloc() 혹은 free()를 사용하기 위해선 #include <stdlib.h>를 통해 라이브러리를 선언해주어야 함.

---

4월 5일



* 문제 1번 :
구조체 형의 포인터 함수 inp() : 이름과 전화번호 입력, 구조체 변수에 저장 후 return, main()에 출력하기.

* 풀이
```c
# include <stdio.h>
# include <stdlib.h>

struct list {
  char *nam;
  char *tel;
};

struct list *inp(struct list *m);
struct list *nalloc();

int main()
{
  struct list *man, *p; // 구조체 이름이 list임, 별다른 의미 X

  man = NULL;

  p = nalloc();
  p = inp(man);

  printf("%10s %10s", p->nam, p->tel);
  free(p->nam); // 기억장소를 해제하고
  free(p->tel);

  return 0;     // 종료한다.
}



struct list *nalloc()
{
  return ((struct list *) malloc(sizeof(struct list)));
}

struct list *inp(struct list *m)
{
  char *name1 = (char *)malloc(10); // char *name1;로만 선언하면 정확히 안 나옴...
  char *tel1 = (char *)malloc(10);

  m = nalloc();

  scanf_s("%10s %10s", name1, 10, tel1, 10); // ㅇ이 줄에서 10은 할당되는 비트수를 의미

  m -> nam = name1;
  m -> tel = tel1;

  return(m);
}
```

* 예시 입출력
(입력 -> kim, 100) -> (출력 -> kim, 100)

* 비고
프로그램에 오류 없음



* 문제 2 :
3개의 노드를 생성하여 linked list 구현 -> 차례대로 출력 -> 기억장소 해제

* 풀이

예를 들어 다음의 노드가 있다 : |이름|점수|   ---    | 
    가령, 첫 번째 노드(헤드)는 |kim|100 |2번째 노트값|,
         두 번째 노드는       |lee |90 |3번째 노트값|,
         세 번째 노드는       |choi|80 |   NULL   |로 구성해야 할 것이다.

```c
# include <stdio.h>
# include <stdlib.h>

struct list {
  char nam*[10];
  int score;
  strict list *link;
};

int main()
{
  struct list *list1, *head. *pre, *next;
  
  head = NULL;
  
  int i;
  for (i=0 i<3 i++) {
    list1 = ((struct list *) malloc(sizeof(struct list))); // 명시적 변환 포함되어있음을 주목. i = 1일 때 malloc이 새로 실행되며 list1은 새 주소값을 가지게 된다.
    
    ;// (if (list1 == NULL) return -1;) -> 입력 못 받은 경우에 대한 처리, C언어 버전별 처리를 용이하게 하기 위함

    scanf_s('%s %d', list1 -> name, 10, &(list1 -> score)); // 문자열과 정수는 & 통해 다르게 취급

    // 링크 생성시 초기 1번만 수행
    if (head == NULL) {
      head = list1; // 이 시점에서 list1은 주솟값을 가지고 있다.
    } else {
      pre -> link = list1;
    }

    list1 -> link = NULL;
    pre = list1; // i = 0일 때, 이 지점에서 list1, head, pre는 모두 malloc()로 생성한 노드에 대한, 같은 값을 가지고 있다.
  }

  for (next = head   next != NULL   next=next->link) {
    print("%s %d \n", next -> name, next -> score);
  }

  while (head != NULL) {
    next = head -> link; // next 변수가 활약하는 지점
    printf("삭제 완료 (%s %d ) \n", head -> name, head -> score);
    free(head);
    head = next; // 2번째 노드를 기억장소에서 해제하기 위함
  }

  return 0;
}

* 비고
노드 구조를 그려서 이해하길 바람.
첫번째 : |  |  |  |, 두번째 : |  |  |  |, 세번째 : |  |  |  |.

## <b>참고</b>