---
title: "네이버 API와 pandas 이용해 지역 자동 채우기"

categories: [마일스톤, 기타 개발]
tags: [마일스톤, 기타 개발]
start_with_ads: true

toc: true
toc_sticky: true

date: 2025-12-11 00:00:00 +0900
last_modified_at: 2025-12-11 00:00:00 +0900
---

## **주소로 지역을 채워주렴**

인천시청 택시운수과에서 요청했고, 부서 팀장님께서 받아들이면서 전달된 업무입니다. 여러가지 복잡한 맥락으로, 협력업체의 시스템으로 관리되는 고객 데이터중에는 주소는 있으나 지역이 누락되어 있는 고객이 상당수 있었는데 시청이 이를 참조할 수 있도록 채워넣어달라고 요청했습니다.

다음과 같이 전통적인 방식으로 처리하라고 안내받았습니다.
1. 고객 주소를 네이버지도 또는 카카오지도에서 검색
2. 도로명주소 등으로 나오는 결과를 마우스로 긁어서 복사
3. 엑셀의 해당 행에 붙여넣기

그런데 처리가 필요한 건 수가 무려 7169건에 달했습니다. 업루량이 많으니 다른 사회복무요원과 나눠서 하라고는 했지만 그래도 인당 이천 개가 넘어가서, 이걸 손으로 모두 채우는 것은 정말 말도 안 되는 시간낭비라고 생각했고 제 방식대로 처리하기로 했습니다.








## **NAVER API 이용**

Naver가 제공하는

![Group107-light](/2026-03-03-sabok-auto-filling/Group107-light.png){: .light }
![Group107-dark](/2026-03-03-sabok-auto-filling/Group107-dark.png){: .dark }
_네이버 API 문서 스크린샷_

> 입력한 주소와 연관된 주소 정보를 검색합니다.

> 입력한 좌표 값을 주소 정보(법정동, 행정동, 지번 주소, 도로명 주소)로 변환합니다.

- [지오코딩](https://api.ncloud-docs.com/docs/ai-naver-mapsgeocoding-geocode)
- [역지오코딩](https://api.ncloud-docs.com/docs/ai-naver-mapsreversegeocoding-gc)

다만 해당 문서의 브레드크럼을 확인해보면 `홈 > AI·NAVER API > Maps (deprecated) > Maps 사용`으로 되어 있는 것을 볼 수 있습니다. 2025년 7월부로 네이버 API가 개편되어 현재는 해당 API가 사용이 불가능한 상태입니다. 이와 관련한 에피소드가 있는데, 후술하겠습니다.

각각 를 입력값으로 받아

입력값
: - `query`
- `coordinate`
- `filter`
- `language`
- `page`
- `count`

문서에서 안내되고 있듯, 터미널에 다음과 같이 작성해보면

```bash
curl --location --request GET 'https://naveropenapi.apigw.ntruss.com/map-geocode/v2/geocode?query=분당구 불정로 6' \
--header 'x-ncp-apigw-api-key-id: {API Key ID}' \
--header 'x-ncp-apigw-api-key: {API Key}' \
--header 'Accept: application/json'
```

결과가 전송됩니다.

- [지오코딩](https://api.ncloud-docs.com/docs/ai-naver-mapsgeocoding-geocode)
- [역지오코딩](https://api.ncloud-docs.com/docs/ai-naver-mapsreversegeocoding-gc)

## **코드 작성**

먼저 데이터 정제가 필요합니다. 주소 정보가 좀 더럽기 때문인데, 예시를 들자면 다음과 같습니다.

|전동휠체어)XX구 XX동000 XXXA XX동 XXX호(XXX-XXXX)|
|X구 XX로XX번길 XX-X(XX동)|
|XX동)XX로XXX번길 X-X|
|휠체어) XX동 XXX-X XXX XXX동 XXX호|
|XX대로XXX번길 XX, X동 XXXX호 (XX동, XX아파트)|
|X/X XX읍 XX리 XXX-X|
|XX주공@XXX/XXX호 (거주지= XXX동 XXXX-X번지 XXX병원)|

이것 외에도 다양한 형태가 있습니다. 예를 들어 단순 아파트명 이름도 "XXX아파트" 또는 "XXX@" 또는 "XXXA" 등 정해진 양식이 없어서 처리가 어려웠습니다. 이때는 한참 AI 에이전트와 MCP, 그리고 그 등에 기반한 Cursor 등 다양한 서비스가 나오기 시작할 때였어서 경험삼아 바이브 코딩으로 만들었습니다. 이 때 완성된 코드는 여러가지 문제로 쓰지는 않았지만 파일은 남아 있습니다. Gemini Pro 2.5를 기준으로 다음과 같이 작성됩니다.

```python
def search_address(self, address):
    max_retries = 3  # 최대 재시도 횟수
    retry_count = 0
    retry_delay = 2  # 초기 재시도 대기 시간 (초)
    
    while retry_count <= max_retries:
        try:
            # 주소 정제
            cleaned_address = self.clean_address(address)
            
            # URL 인코딩
            encoded_address = quote(cleaned_address)
            url = f"{self.base_url}?query={encoded_address}"
            
            # API 요청 (제한 없음) - 타임아웃 설정 추가
            response = requests.get(url, headers=self.headers, timeout=(5, 10))  # 연결 5초, 읽기 10초 타임아웃
            
            # 디버깅용 응답 정보 (경합 방지를 위해 락 사용)
            with self.print_lock:
                print(f"주소: {cleaned_address} - API 응답 코드: {response.status_code}")
            
            # 응답 상태 코드 확인
            if response.status_code == 429:  # Rate limit 초과
                # 잠시 대기 후 재시도
                time.sleep(retry_delay)
                retry_count += 1
                retry_delay *= 2  # 지수 백오프 방식으로 대기 시간 증가
                continue
            elif response.status_code != 200:
                with self.print_lock:
                    print(f"API 오류 발생 (상태 코드: {response.status_code}): {response.text}")
                return "API 오류"
            
            # 응답 처리
            result = response.json()
            
            # 문서에 맞게 응답 검증 및 처리
            if result.get("status") == "OK" and result.get("addresses") and len(result["addresses"]) > 0:
                # 첫 번째 결과 사용
                address_info = result["addresses"][0]
                
                # addressElements에서 시/도, 시군구, 동/면 추출
                sido = None
                sigugun = None
                dongmyun = None
                
                for element in address_info.get("addressElements", []):
                    if "SIDO" in element.get("types", []):
                        sido = element.get("longName", "")
                    elif "SIGUGUN" in element.get("types", []):
                        sigugun = element.get("longName", "")
                    elif "DONGMYUN" in element.get("types", []):
                        dongmyun = element.get("longName", "")
                
                # addressElements에서 행정동(ADMNM) 추출
                hdong = None
                for element in address_info.get("addressElements", []):
                    if "ADMNM" in element.get("types", []):
                        hdong = element.get("longName", "")
                        break  # 첫 번째 행정동만 사용

                # 결과 생성 (행정동 우선 반환)
                if hdong:
                    return hdong
                # 기존 방식 유지 (시도, 시군구, 동/면)
                if sido and sigugun and dongmyun:
                    return f"{sido} {sigugun} {dongmyun}"
                elif sido and sigugun:
                    return f"{sido} {sigugun}"
                elif sido:
                    return sido
            
            # API에서 결과를 찾지 못함
            with self.print_lock:
                print(f"API에서 '{cleaned_address}'에 대한 결과를 찾지 못했습니다.")
            return "매칭 실패"
            
        except requests.ConnectionError as e:
            with self.print_lock:
                print(f"연결 오류 발생: {str(e)}")
            retry_count += 1
            if retry_count <= max_retries:
                with self.print_lock:
                    print(f"재시도 중... ({retry_count}/{max_retries}) - {retry_delay}초 후 재시도")
                time.sleep(retry_delay)
                retry_delay *= 2  # 지수 백오프 방식으로 대기 시간 증가
            else:
                return "API 오류 (연결 실패)"
        except requests.Timeout as e:
            with self.print_lock:
                print(f"타임아웃 오류 발생: {str(e)}")
            retry_count += 1
            if retry_count <= max_retries:
                with self.print_lock:
                    print(f"재시도 중... ({retry_count}/{max_retries}) - {retry_delay}초 후 재시도")
                time.sleep(retry_delay)
                retry_delay *= 2  # 지수 백오프 방식으로 대기 시간 증가
            else:
                return "API 오류 (타임아웃)"
        except Exception as e:
            with self.print_lock:
                print(f"API 오류 발생: {str(e)}")
            return "API 오류"
```
{: file="main.py" }

엄청 나쁘진 않은데, 개인적으로는 전체적으로 불안정하다는 느낌을 받았습니다. 설명을 위한 주석의 남발은 물론이고, 무엇보다 제가 이 코드를 소유하고 있다는 느낌이 잘 들지 않았습니다. 다만 흐름상의 참조는 되어서 다시 다음과 같이 작성되었습니다.

## **해결2. 지오코딩과 역지오코딩 이용**

```python
def get_region_from_address(address: str):
    url = f"{geocode_baseurl}?query={address}"
    headers = {
        "x-ncp-apigw-api-key-id": client_id,
        "x-ncp-apigw-api-key": client_secret,
        "Accept": "application/json"
    }

    try:
        geocoding_response = requests.get(url, headers=headers, timeout=(5, 10))
    except requests.exceptions.ConnectionError as e:
        print(f"Geocode 연결 오류: {e}")
        return None

    if geocoding_response.status_code != 200:
        return None

    if geocoding_response:
        data = geocoding_response.json()
        if data and 'addresses' in data and data['addresses']:
            first_address = data['addresses'][0]
            coord_x = first_address.get('x')
            coord_y = first_address.get('y')
        else:
            return None

    if not coord_x or not coord_y:
        return None

    reverse_params = {
        "coords": f"{coord_x},{coord_y}",
        "output": "json",
        "orders": "admcode"
    }
    try:
        reverse_geocoding_response = requests.get(reversegeocode_baseurl, headers=headers, params=reverse_params, timeout=(5, 10))
    except requests.exceptions.ConnectionError as e:
        print(f"Reverse geocode 연결 오류: {e}")
        return None

    if reverse_geocoding_response.status_code != 200:
        return None

    if reverse_geocoding_response:
        reverse_data = reverse_geocoding_response.json()
        if reverse_data and 'results' in reverse_data and reverse_data['results']:
            for result in reverse_data['results']:
                if result.get('name') == 'admcode':
                    region = result.get('region')
                    if region:
                        area1 = region.get('area1', {}).get('name', '')
                        area2 = region.get('area2', {}).get('name', '')
                        area3 = region.get('area3', {}).get('name', '')
                        area4 = region.get('area4', {}).get('name', '') # area4는 보통 리/가/구 등 세부 동 정보
                        full_name = f"{area1} {area2} {area3}"
                        if area4:
                            full_name += f" {area4}"
                        return full_name.strip()
    return None
```
{: file="main.py" }

테스트는

```bash
curl --location --request GET "https://maps.apigw.ntruss.com/map-geocode/v2/geocode?query=%EB%85%BC%ED%98%84%EB%8F%99%20%EB%82%A8%EB%8F%99%EA%B5%AC%20%ED%98%B8%EA%B5%AC%ED%8F%AC%EB%A1%9C" ^
    --header "x-ncp-apigw-api-key-id: xxxxxxxxxx" ^
    --header "x-ncp-apigw-api-key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" ^
    --header "Accept: application/json"
```

로 했습니다.

`.xlsx`로 형식의 엑셀 파일 데이터를 `pandas` 데이터프레임 형태로 변환한 뒤

## **다시, 법정동이 아닌 행정동으로 채워라**

> "보내주신 리스트를 기준으로 업데이트 하였으나 지역을 행정동이 아닌 법정동으로 주신 고객은 업데이트 되지 않았습니다."

사전에 안내받지 않았는데 고객 주소는 법정동이 아닌 행정동 형식으로만 등록 가능하다고 회신받았습니다.

결과값 검수용으로 [행정안전부 > 업무안내 > 자치혁신실 > 주민등록,인감 > 가장 최근 공고문](https://www.mois.go.kr/frt/bbs/type001/commonSelectBoardList.do;jsessionid=Sts__z7tpvlYn3TZmotdQirIgfYhYb4aRcMViuf6.node40?bbsId=BBSMSTR_000000000052)에서 `jscode.zip` 파일을 다운로드 받았습니다. 해당 압축 파일에는 `KIKcd_B_yyyymmdd.xlsx`, `KIKcd_H_yyyymmdd.xlsx`, `KIKmix_yyyymmdd.xlsx` 세 개 파일이 들어 있으며 B가 법정동, H가 행정동입니다. 예를 들어 두 자료가 혼합된 `KIKmix` 파일을 열어보면, 2025년 11월 3일자 자료를 기준으로 다음과 같이 작성되어 있습니다.

|행정동코드|시도명|시군구명|읍면동명|법정동코드|동리명|생성일자|말소일자|
|---|---|---|---|---|---|---|---|
|1100000000|서울특별시|||1100000000|서울특별시|19880423||
|1111000000|서울특별시|종로구||1111000000|종로구|19880423||
|1111051500|서울특별시|종로구|청운효자동|1111010100|청운동|20081101||
|1111051500|서울특별시|종로구|청운효자동|1111010200|신교동|20081101||
|1111051500|서울특별시|종로구|청운효자동|1111010300|궁정동|20081101||
|1111051500|서울특별시|종로구|청운효자동|1111010400|효자동|20081101||
|1111051500|서울특별시|종로구|청운효자동|1111010500|창성동|20081101||

법정동은 법률로 지정된 행정구역의 공식 명칭이고 행정동은 행정상의 편의를 위해 나눈 이름입니다. 서울 강남의 동을 예시로 들자면 "논현1동", "일원본동" 등이 행정동이고, "논현동", "일원동"이 법정동입니다. 법정동명과 행정동명은 일치하는 경우도 있고, 행정동명이 법정동명에서 "1동"과 "2동", 또는 "제1동"과 "제2동"으로 나뉘는 경우도 있으며, 행정동명과 법정동명이 완전히 다른 경우도 있습니다.

## **실수**

50만원 에반데

## **여담**

다른 사회복무요원의 의견의 영향을 받아 일부로 클래스를 사용하지 않았고, 코드 정돈에도 큰 신경을 쓰지 않았습니다. 빠른 처리도 중요했고







{% comment %}
2025-07-17

## **사회복무요원**

- 인천교통공사의 교통복지팀에 사회복무요원으로 있다보면 주로 반복적인 업무를 해결해드리지만 가끔은 이벤트성으로 특이한 업무도 발생합니다.
- 교통복지팀 업무 설명 (EKSYS)
- 시 > 팀장 > 팀원 > 사회복무요원 인계과정 (시: 내가 이걸 참조하겠다)
- 업무 사이즈: 만 단위(25600)에 달하는 업무과정, 그중에 데이터 추리고 6700건만 남김
- 상담원이 채운 주소 정보의 더러움 (Ex. 휠X와 같은 것들)
- AI NAVER API와 MAPS API, 지오코딩과 역지오코딩
- 처음 바이브 코딩을 통한 업무 보조와, 나중의 법정동&행정동 문제 설명
- 어쩔 수 없는 부분은 손으로 해결, 인계, 해결완료

25년 3월, 처음에는 AI NAVER API의 지오코딩으로 채워넣을 수 있는 것은 채워넣고 프로그램으로 해결이 어려운 내용은 카카오지도와 네이버지도를 이용해 수기로 해결함. 그러나 전달도 잘 안 됐고 담당 직원이 관심을 놓으면서 흐지부지됨.

25년 7월, 같은 업무가 재점화되었고 이전과 같은 방식으로 지역을 채웠으나 EKSYS에서 "법정동이 아닌 행정동만 추가 가능합니다"라고 답변을 주면서, 일이 복잡해짐. 네이버 API를 이용할 때 행정동 정보는 역지오코딩으로만 얻을 수 있었으므로, 지오코딩 => 역지오코딩 순의 과정을 통해 행정동 정보를 얻음.

안녕하세요. eKsys 사길수입니다.

업데이트 완료되었습니다.

감사합니다.

From: jcall@ictr.or.kr <jcall@ictr.or.kr>
Sent: Thursday, August 7, 2025 5:45 PM
To: nobinea@eksys.co.kr
Cc: "이정익" <it202324@ictr.or.kr>
Subject: RE: RE: Re: RE: 안녕하세요, 이동약자지원센터 사무실입니다. [고객정보 업데이트 관련 문의]
 
안녕하세요, 인천이동약자지원센터입니다.
 
죄송합니다, 지역을 수기로 작성, 확인하는 과정에서 실수가 있었습니다. 행정표준코드를 참고하여 일괄 수정했사오니, 확인해주시면 감사하겠습니다.
사무실에서는 고객정보를 하나하나 수정하기가 어려워 지역과 타지역을 새로 업데이트해주시면 감사하겠습니다.
 
행정표준코드에 따르면 강원도가 아닌 강원특별자치도로 등록되어 있으나, 편의를 위해 강원도로 작성된 시트 하나와 강원특별자치도로 작성된 시트 하나로 유형을 나누어 보내드렸습니다.

감사합니다.
────── 원본 메일 ──────
보낸사람 : <nobinea@eksys.co.kr>
받는사람 : <jcall@ictr.or.kr>
참조 : <eseok.hwang@eksys.co.kr>, <ldw@eksys.co.kr>
받은날짜 : 2025-08-04 (월) 09:11:38
제목 : RE: Re: RE: 안녕하세요, 이동약자지원센터 사무실입니다. [고객정보 업데이트 관련 문의]
 
안녕하세요. eKsys 사길수입니다.
 
명칭을 행정동 코드표와 통일해 주시기 바랍니다.
 
강원특별자치도 = 강원도
서울특별자시치 = 서울특별시
인천 = 인천광역시
노우너구 = 노원구
 
본사에서 업데이트 시 지역 이름을 기준으로 형정동 코드를 업데이트를 진행합니다.
 
오자, 탈자를 일일히 검수하여 업데이트 해 드릴 수 없습니다.
 
감사합니다.
 
From: jcall@ictr.or.kr <jcall@ictr.or.kr>
Sent: Friday, August 1, 2025 1:27 PM
To: "사길수" <nobinea@eksys.co.kr>
Subject: RE: Re: RE: 안녕하세요, 이동약자지원센터 사무실입니다. [고객정보 업데이트 관련 문의]
 
안녕하세요, 인천이동약자지원센터입니다.
 
다름이 아니라, 업데이트된 고객정보를 확인해봤는데 여전히 누락된 고객정보가 다수 있어, 
사무실에서는 고객정보를 하나하나 수정하기가 어려워 지역과 타지역을 새로 업데이트해주시면 감사하겠습니다.
 
감사합니다.
 
────── 원본 메일 ──────
보낸사람 : "사길수" <nobinea@eksys.co.kr>
받는사람 : "교통복지팀 문학파트" <jcall@ictr.or.kr>
참조 : "이정익" <it202324@ictr.or.kr>, "황은석" <eseok.hwang@eksys.co.kr>, "이대우" <ldw@eksys.co.kr>
받은날짜 : 2025-07-31 (목) 13:32:29
제목 : Re: RE: 안녕하세요, 이동약자지원센터 사무실입니다. [고객정보 업데이트 관련 문의]
 
안녕하세요. eKsys 사길수입니다.
 
고객정보 업데이트 완료되었습니다.
 
감사합니다.

2025년 7월 28일 (월) 오후 2:56, "교통복지팀 문학파트" < jcall@ictr.or.kr>님이 작성:
법정동이 아닌 행정동을 기준으로 다시 수집하여 업데이트했습니다.
저번과 마찬가지로, 사무실에서는 고객정보를 하나하나 수정하기가 어려워 지역과 타지역을 새로 업데이트해주시면 감사하겠습니다.
감사합니다.

────── 원본 메일 ──────

보낸사람 : <nobinea@eksys.co.kr>
받는사람 : <jcall@ictr.or.kr>
참조 : "이정익" <it202324@ictr.or.kr>, <eseok.hwang@eksys.co.kr>, <ldw@eksys.co.kr>
받은날짜 : 2025-07-11 (금) 17:17:29
제목 : RE: 안녕하세요, 이동약자지원센터 사무실입니다. [고객정보 업데이트 관련 문의]

안녕하세요. eKsys 사길수입니다.
등록 고객 중 ADMIN_CODE가 누락되어 있는 총 회원 수는 7,169명이나 보내 주신 리스트는 6,106명입니다.
보내주신 리스트를 기준으로 업데이트 하였으나 지역을 행정동이 아닌 법정동으로 주신 고객은 업데이트 되지 않았습니다.
현재 DB에 입력된 고객 중 상태 값이 등록이며 ADMIN_CODE가 없는 고객 리스트를 첨부해 드리도록 하겠습니다.
감사합니다. 

From: jcall@ictr.or.kr <jcall@ictr.or.kr>
Sent: Friday, July 11, 2025 3:54 PM
To: "사길수" <nobinea@eksys.co.kr>
Cc: "이정익" <it202324@ictr.or.kr>
Subject: 안녕하세요, 이동약자지원센터 사무실입니다. [고객정보 업데이트 관련 문의]

안녕하세요, 이동약자지원센터 사무실입니다.
시의 요청이 있어 고객정보 중 지역정보가 누락되어 있는 6106개 가량의 건에 대해 지역을 새로 채우게 되었고, 고객 목록 통계 파일을 바탕으로 고객정보 중 누락이 되어 있는 건에 대해 사무실에서 지역을 작성했습니다.
사무실에서는 고객정보를 하나하나 수정하기가 어려워, 지역과 타지역을 새로 업데이트해주시면 감사하겠습니다. 파일은 첨부해드렸습니다.
감사합니다.
{% endcomment %}