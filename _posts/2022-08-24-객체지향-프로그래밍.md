---
title:  "객체지향"

categories:
  - 프로그래밍 기초
tags:
  - [객체 지향 프로그래밍]

toc: true
toc_sticky: true
 
date: 2022-08-24
last_modified_at: 2022-08-24
---

<h2><b>객체지향 프로그래밍(OOP)</b></h2>
객체지향 프로그래밍이 무엇인지 검색해봐도 비유법 없이 개념을 세세하게 설명하는 글을 찾기가 힘들었다.  
보조관념에 형성되어 있는 문화적 속성을 원관념에 적용할 수 있다는 것은 비유법의 장점이지만, 단점은 보조관념과 원관념이 결국에는 서로 다른 개념이라는 것이다. 때문에 개념을 정확히 살펴잡는 것에 혼동이 있었다.  

더불어 사람들이 드는 비유가 별로 재밌지 않았다. 붕어빵과 붕어빵 틀, 책과 수학의 정석, 자동차 설계도와 생산된 자동차, 공장과 공산품. 이 정도의 비유를  

비유법 없이 작성된 글도 표현이 추상적이다라는 인상이 드는 글이 많았다. 아마 내가 입문자였기 때문에 좀 더한 친절을 기대했기 때문일 수도 있다.  
다만 어쨌든 입문자의 눈에 보이기에 많은 글들은 어느 순간 설명이 툭 끊겨있는 느낌이었고, 그러한 글들을 피해 작성이 완전한 것으로 보이는 글을 찾아보아도 찾기가 어려웠다.

이런 불편함이 있었다고 토로한다고 내 표현이 재밌어지거나 정확해지지는 않지만, 문제를 인식하고 개선본을 직접 만들어 보는 것에는 재미가 있다.  
그래서 나만의 방식으로 객체지향 프로그래밍용 개념(= 특수어휘)을 정리해 보았다.

---

<h3>큰 규모의 단일 코드에서 아름다움 대신 복잡함이 느껴지기 시작할 때</h3>
객체지향의 개념이 나타났다. 그래서 객체지향의 가장 강한 목표는 "필요한 함수와 데이터를 한군데에 묶어 외부의 코드가 접근할 수 없게 만드는 것"이다. 이것은 코드간 의존성을 영점에 가깝게 줄이고 각 코드가 독립적으로 기능할 수 있게 만드는 효과를 가져온다. 각 코드가 독립적으로 기능하기 때문에 문제가 되는 코드를 따로 도려내어도 문제가 되지 않고, 필요하다면 코드를 치료한 뒤 제자리에 부착할 수도 있다. 잘 구현된 객체지향 코드에서는 이런 의도된 이점을 얻을 수 있다.

단점은 연산량이 늘어나 메모리 요구량과 코드 실행 시간이 늘어난다는 것이다. 이것은 절차지향 코드에 비교했을 때 그렇다는 것이며 ~???


[내가 오해했던 것]
객체지향이라는 이름은 유형에 관한 것이 아니라 개념에 관한 것이다. 이것은 "객체지향 언어"라는 표현에서 비롯되기 쉬운 오해인데, 객체지향 언어라고 해서 객체지향 프로그래밍이 강제되는 것은 아니다.

<h3>객체지향의 과정</h3>
클래스를 작성한다.








<h4>첫째, 클래스(Class)</h4>
객체를 생성하기 위해 변수와 메소드를 정의하는 공간이다. 일종의 견본(Template)이다.
클래스를 만든다는 것은 

<h4>Second, 네임스페이스(NameSpace)</h4>


<h4>三番目, 필드(Field)와 메서드(Method)</h4>
> a member variable (sometimes called a member field) is a variable that is associated with a specific object, and accessible for all its methods (member functions). - 영문 위키백과(2022.08.24)

사실은 멤버(Member)라고 불리는 개념이다. 필드와 메서드를 함쳐 멤버(Member)라고 부른다.

필드와 멤버는 클래스에 작성되는 변수와 함수를 말하는데, 일반적인 프로그래밍(= 절차지향 프로그래밍, PP)에서 보이던 개념과는 또 다른 중요한 개념이기 때문에 별도의 이름을 갖고 있다.
각각 클래스에서 속성(Property)과 기능(function)의 역할을 맡고 있다.

<h4>第四点, 객체(Object)와 인스턴스(Instance)</h4>

객체와 인스턴스 클래스에 정의된 것을 토대로 메모리에 할당된 것을 말한다.

객체는 "추상화"라는 특징적 표현과는 별개로, 그 개념 자체가 일부는 추상적이라는 것을 전제로 설명하는 것이 조금 보편적인 것 같다. 추상적이라는 것은 측정할 수 있는 것도 아니고 속성도 전원 스위치처럼 0과 1로 이분되는 것이 아니기 때문에 어느 정도는 맞는 말이지만, 읽는이가 갈피를 잘 못 잡게 하는 것이 흠이다 싶다.  

내 생각엔 Object와 객체(客體)사이에 어감의 차이가 있기 때문인 것 같다.
한국어에서 객체는 객관적 상관물, 

객체는 new 연산자로 생성한다. Java든 C#이든 동일하다.

<h4>접근 제한자</h4>

public
모든 외부 객체에 대해 접근을 허용한다.
private
외부의 접근을 차단한다. 파생클래스에서도 접근할 수 없다.
protected
상속 클래스에 대해서만 접근을 허용한다.
static
같은 폴더에 있는 객체의 

++ C#에서는 다음이 추가된다.
internal
.NET 어셈블리 안의 다른 클래스에서 접근할 수 있다.  
[.NET](https://dotnet.microsoft.com/en-us/)은 마이크로소프트가 개발한 프레임워크, [어셈블리](https://docs.microsoft.com/ko-kr/dotnet/standard/assembly/)는 .exe나 .dll과 같이 .NET 프로그램의 배포 단위이다.  
public, private, protected 등이 클래스의 계층구조에 따라 논리적으로 접근 권위를 결정한다면, internal은 같은 어셈블리 내에 있느냐에 따라 물리적으로 접근 권위를 결정한다. 즉 동일 어셈블리 안이라면 public, 어셈블리 외부라면 private로 작동한다.
protected internal
어셈블리 내의 클래스 중 파생클래스에 한해 접근을 허용한다.



<h4>메서드</h4>

<h4>식별자</h4>

<h4>멤버 변수</h4>
<h4>멤버 함수</h4>
<h4>생성자와 소멸자</h4>
<h4>[C#] 인덱서(indexer)</h4>
인덱스는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용되는 인자로, "색인"이라는 뜻이다.  
C#에서 인덱서(er)는 클래스로부터 생성된 각 객체를 배열처럼 취급해
<h4></h4>
<h4></h4>
<h4></h4>
<h4></h4>
<h4></h4>
<h4></h4>
