---
title:  "게임 프로그래밍 패턴: SOLID 원칙"

categories: [프로그래밍, 패러다임]
tags: [유니티]

toc: true
toc_sticky: true

date: 2023-12-06
last_modified_at: 2023-12-06
---

# **유니티에서**

게임 프로그래밍 패턴을 주제로 [E북](https://blog.unity.com/games/level-up-your-code-with-game-programming-patterns)을 직접 발간했다는 사실을 알게 되었습니다. 그것도 2022년 10월에, 글을 쓰는 시점에서 별로 오래되지 않은 시점에 말이죠. 전부 영어로 작성되어 있어 하나하나 직접 번역해볼까 하고 생각해보다가, 찾아보니 국내에 [비공식 번역본](https://arainablog.tistory.com/600)을 만드신 분이 계셔서 내용만 간단하게 리뷰하려 합니다. 원본은 [여기](/assets/pdf/2023-12-06-unity-programming/level-up-your-code-with-game-programming-patterns.pdf)를 클릭하면 확인할 수 있습니다.

<br>

# **SOLID 원칙**

도입부는 SOLID 원칙에 대해 소개하고 있습니다. SOLID는 이해하고 쉽고, 유연하고, 유지보수가 쉬운 코드를 작성하기 위한 전략으로, 아래처럼 총 5개 원칙으로 구성되어 있습니다.

- **SRP** (Single Responsibility Principle)
- **OCP** (Open Close Principle)
- **LSP** (Liskov Substitution Principle)
- **ISP** (Interface Segregation Principle)
- **DIP** (Dependency Inversion Principle)

굳이 유니티가 아니더라도 프로그램 설계에 있어서는 포괄적으로 적용할 수 있는 내용들로 이루어져 있습니다. 하나하나 살펴보겠습니다.

# **SRP (단일책임의 원칙)**

SRP는 **클래스는 하나의 기능과 하나의 책임을 가진다는 원칙**입니다. 하나의 클래스에 여러 책임이 혼재되어 있다면, 이를 개별 클래스로 분할하여 개별 클래스의 복잡도를 낮추는 것이죠. 이 원칙을 적용할 때에는 세 가지 요소를 지켜야 합니다.

- **가독성**: 클래스는 읽기 쉬워야 합니다. 정해진 것은 없지만, 일반적으로 200~300줄 정도의 길이가 많이 선호되니 참고할 수 있습니다.
- **확장성**: 상속하는 클래스는 코드 수정이 용이하도록 간단해야 합니다.
- **재사용성**: 클래스가 작은 모듈 형식을 갖추어 게임의 다른 부분에서도 이 코드를 재활용할 수 있어야 합니다.

SRP 원칙이 지켜지지 않을 때 발생하는 문제는, 하나의 클래스가 너무 많은 책임을 지니게 되면 비대해지고, 비대해진 클래스는 나중에 이해하기 어려워진다는 겁니다. 이 문서는 '비대한' 클래스의 예시로 아래의 UnrefactoredPlayer 클래스를 제시합니다.

```cs
public class UnrefactoredPlayer : MonoBehaviour
{
    [SerializeField] private string inputAxisName;
    [SerializeField] private float positionMultiplier;
    private float yPosition;
    private AudioSource bounceSfx;

    private void Start()
    {
        bounceSfx = GetComponent<AudioSource>();
    }

    private void Update()
    {
        float delta = Input.GetAxis(inputAxisName) * Time.deltaTime;
        
        yPosition = Mathf.Clamp(yPosition + delta, -1, 1);
        
        transfrom.position = new Vector3(transform.position.x, 
        yPosition * positionMultiplier, transform.position.z);
    }

    private void OnTriggerEnter(Collider other)
    {
        bounceSfx.Play();
    }
}
```

이 클래스는 사운드 재생, 사용자 입력 관리, 움직임 제어 등 여러가지 책임이 혼재되어 있고, 따라서 유지보수가 어렵다는 문제가 있습니다. 이 문서는 SRP 원칙을 적용하여, 가령 아래와 같이 개선할 것을 주문합니다.

```cs
[RequireComponent(typeof(PlayerAudio), typeof(PlayerInput), typeof(PlayerMovement))]
public class Player : MonoBehaviour
{
    [SerializeField] private PlayerAudio playerAudio;
    [SerializeField] private PlayerInput playerInput;
    [SerializeField] private PlayerMovement playerMovement;

    private void Start()
    {
        playerAudio = GetComponent<PlayerAudio>();
        playerInput = GetComponent<PlayerInput>();
        playerMovement = GetComponent<PlayerMovement>();
    } 
} 

public class PlayerAudio : MonoBehaviour
{
    ... 
} 

public class PlayerInput : MonoBehaviour
{
    ... 
} 

public class PlayerMovement : MonoBehaviour
{
    ... 
}
```

사운드 재생, 사용자 입력 관리, 움직임 제어 세 가지 기능을 개별 클래스로 분할했습니다. SRP 원칙을 적용하여 하나의 클래스에 하나의 책임을 맡게 한 결과 가독성도 좋아지고, 유지보수의 난이도도 내려갔음을 확인할 수 있습니다.

# **OCP (개방-폐쇄 원칙)**

OCP는 **클래스들을 확장할 수 있도록 개방하되, 수정은 불가하도록 폐쇄한다는 원칙**입니다. 기존의 코드를 수정하지 않고 새로운 기능을 생성할 수 있어야 한다는 것이죠.

OCP 원칙이 지켜지지 않을 때 발생하는 문제점은 유지보수의 어려움과 나쁜 확장성입니다. 이 문서는 사각형이나 원 등 도형의 면적을 구하는 AreaCalculator 클래스를 예시로 듭니다.

```cs
public class AreaCalculator 
{ 
    public float GetRectangleArea(Rectangle rectangle) 
    { 
        return rectangle.width * rectangle.height; 

    } 

    public float GetCircleArea(Circle circle) 
    { 
        return circle.radius * circle.radius * Mathf.PI; 
    } 
} 

public class Rectangle 
{ 
    public float width; 
    public float height; 
} 

public class Circle 
{ 
    public float radius; 
}
```

이 코드는 정상적으로 동작하지만, 육각형, 팔각형 등등 다른 도형을 추가하고 싶으면 메서드를 새로 작성해야 합니다. 따라서, 코드를 확장할 때마다 AreaCalculator 클래스는 빠르게 복잡해진다는 문제가 있습니다.

대안은 인터페이스(interface)나 추상화(abstraction)를 사용하는 겁니다. 추상 메서드와 추상 클래스를 사용하게 되면, 예를 들어 아래와 같이 개선할 수 있습니다.

```cs
public abstract class Shape
{
    public abstract float CalculateArea();
}
```

```cs
public class Rectangle : Shape
{
    public float width;
    public float height;

    public override float CalculateArea()
    {
        return width * height;
    }
}

public class Circle : Shape
{
    public float radius;

    public override float CalculateArea()
    {
        return radius * radius * Mathf.PI;
    }
}
```

```cs
public class AreaCalculator
{
    public float GetArea(Shape shape)
    {
        return shape.CalculateArea();
    }
}
```

Shape라는 이름의 추상클래스를 만들어 확장성을 취했습니다. 이를 상속하는 사각형, 원 클래스를 별도로 만들어 세부 코드를 작성하고, 원래의 AreaCalculator 클래스는 Shape형 객체를 매개변수로 받아 면적을 반환합니다. 이렇게 작성하면 확장성도 용이해지고, 무엇보다 코드 디버깅이 쉬워진다는 장점이 있습니다. 가령, Circle 클래스에서 오류가 발생할 경우 Circle 클래스만 찾아 수정하면 됩니다.

# **LSP (리스코프 치환 원칙)**

LSP는 **파생된 클래스가 필히 기반이 되는 클래스를 대신할 수 있어야 한다**는 원칙입니다.

이 문서는 Vehicle이라는 이름의 클래스를 통해 승용차(car)와 트럭(truck)을 만드는 경우를 아래와 같이 가정합니다.

```cs
public class Vehicle
{
    public float speed = 100;
    public Vector3 direction;
    
    public void GoForward()
    {
        ... 
    }

    public void Reverse()
    {
        ... 
    }

    public void TurnRight()
    {
        ... 
    }

    public void TurnLeft()
    {
        ... 
    }
}
```