---
title: "모바일 감성 게임 개발하기: 프로토타입 개발 과정"
description: "유니티를 이용한 감성 모바일 게임 프로토타입 개발기를 정리합니다."

categories: [프로그래밍, 마일스톤]
tags: [프로그래밍, 유니티, C#, 기획, 개발일지]
start_with_ads: true

toc: true
toc_sticky: true

mermaid: true

date: 2024-04-11
last_modified_at: 2024-04-11
---

## **들어가며**

> **[전 글](https://hynrng.github.io/posts/armonia-planning/)**로부터 이어집니다.
{: .prompt-info }

## **에셋**

- 사전에 어떤 느낌이 들면 좋을지 어떻게 생각했는지.

### **단락1**

![buildings](/2024-04-11-armonia-developing/buildings.png)
_그린 건물 이미지_

- 그래서 이런 이미지가 만들어졌음.
- "수작업" 느낌이 났으면 좋겠어서 직선 도구도 최대한 사용하지 않았음.
- 그런 느낌이 나서 마음에 든다고 생각함.

### **단락2**

## **개발**

좀 길어질 것 같다 싶으면 어김없이 분할함.
        - 특히, SOLID 원칙 중 단일원칙 책임을 의식하면서, 충분히 준수할 수 있도록 노력했음.

### **클래스 설계**

```mermaid
classDiagram
    class MainManager
    class ObjectGenerator {
        + Livings : List~GameObject~
        + NonLivings : List~GameObject~
        + Population$ : Dictionary~string, int~
    }
    class BackgroundGenerator
```

```mermaid
classDiagram
    class Living
    class NonLiving

    Living <|-- People
    Living <|-- Pigeon
    NonLiving <|-- VendingMachine
    NonLiving <|-- Bench
```

그리고 아래와 같은 클래스들.


- 생명체와 비생명체 오브젝트를 구분함

### **맵 생성**

```mermaid

```

- 생성과 관련하여 꼼수를 사용함
    - 한 번 생성된 맵은 게임 종료 시점까지 끝까지 남아있어야 함. 그런데 이렇게 구현하면 플레이타임이 길어질 수록 저장해야 하는 데이터가 점점 많아지게 됨.
    그래서 플레이어의 위치에 기반하여 오브젝트가 생성되도록 함. 매 판 다른 경험을 제공하기 위해, 게임이 시작될 때 규칙이 랜덤으로 지정되고, 한 번 지정된 규칙을 따라 오브젝트가 생성되도록 만들었음. (플레이어로부터 일정 거리 이상 떨어지면 오브젝트가 삭제됨으로서 프로그램이 부담해야 하는 오브젝트의 수는 적게 유지됨)

### **오브젝트 스폰**

```mermaid

```

### **상호작용**

```mermaid
sequenceDiagram
    autonumber
    VendingMachine.cs -->> People.cs: Attract()
    People.cs ->> PeopleStateMachine.cs: CurrentState = PeopleVendingMachineState
    PeopleStateMachine.cs ->> People.cs: PlayInteractionAnimation()
    People.cs -->> People.cs: StopInteraction()
```

오브젝트가 주체적으로 상호작용 대상을 정하는 대신 상호작용 주체가 되는 오브젝트가 상호작용을 호출하도록 했습니다. Coroutine 속에서 Physics.OverlapBox를 이용하여 범위 내의 오브젝트를 일정시간 간격마다 구한 뒤, 그 중 랜덤한 오브젝트에 대해 상호작용을 호출하도록 만들었습니다. 세부 특징은 다음과 같습니다.

- `Physics.OverlapBox()`을 이용했습니다.
- 상태 패턴을 이용했습니다.

이것도 너무 복잡한 것 같습니다. 상호작용 부분은 이것보다 더 간단하게 구현하는 방법이 있나 궁금합니다.

## **마치며**

- 지금까지 개발해보니 어쩌구 저쩌구 

**[이전 프로젝트](https://hynrng.github.io/posts/palette-developing/)**에서 범했던 실수 하나가 높은 은닉화를 달성하겠답시고 `private` 키워드를 너무너무 애용했다는 겁니다. 어떤 상수값을 수정하려면 클래스를 열고 해당 변수가 있는 코드 열을 찾아 수정해줘야 하는 불편함이 있었죠.

이번에는 대신 수정이 잦은 변수를 `public`으로 선언해 인스펙터 창에서 빠르게 수정할 수 있도록 구성해봤는데 이제까지 제가 뭘 한걸까 싶을 정도로 너무 편했습니다.

- #region 정말 유용하게 썼음. Coroutine, Public Methods, Animation Events 등으로 나누어서 작성하니까 너무 편하고, 또 주석이 들러붙지 않아 코드도 깔끔하게 유지할 수 있었음. VsCode의 flip 확장 프로그램은 덤.

- 향후 남은 과제는 다음과 같음.
    - 어쩌구 저쩌구