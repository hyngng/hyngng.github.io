---
title:  "유니티 | 코루틴 사용해 이미지 페이드아웃 효과 구현"

categories: [프로그래밍, 유니티]
tags: [프로그래밍, 유니티]

toc: true
toc_sticky: true

date: 2023-06-19
last_modified_at: 2023-08-02
---

<br>

페이드(Fade) 효과를 구현하기 위한 핵심 알고리즘 자체는 복잡하지 않지만, 전통적인 방식으로 `Image.color()` 함수의 투명도 매개변수에 적용하려다보니 값이 기준을 초과할 때 의도치 않은 사이클이 발생하는 문제가 있었다. 처음 작성했던 코드는 아래와 같다.

<br>

```cs
private Image _Image;



private void FadeOut()
{
    if (_Image.color.a - .1f > 0) transparency -= .1f;
    else if (_Image.color.a - .1f < 0) transparency -= 0;

    _Image.color = new Color32(1f, 1f, 1f, transparency);
}
```

<br>

기준값을 넘겼을 때 투명도(transparency)값이 초기화되는 것은 `Color32()`의 매개변수 형식이 `byte`이기 때문인 것으로 추측한다. 어찌저찌 해결할 수 있어 보이긴 했지만, 코루틴을 사용하는 것이 더 간단해보여 바로 도전했다.

<br>

```cs
private Coroutine FadeCoroutine;
private float _fadeSpeed, _targetAlpha;



private void Update()
{
    if (FadeCoroutine != null) StopCoroutine(FadeCoroutine);
    FadeCoroutine = StartCoroutine(Fade(0f));
}



private IEnumerator Fade(float targetAlpha)
{
    Color startColor = Image.color;
    Color targetColor = new Color(startColor.r, startColor.g, startColor.b, targetAlpha);

    float t = 0f;
    while (t <= 1f)
    {
        t += Time.deltaTime * _fadeSpeed;
        Image.color = Color.Lerp(startColor, targetColor, t);
        yield return null;
    }
}
```

<br>

페이드아웃, 페이드인 효과를 동시에 구현하기 위해 매개변수를 받는 `Fade()` 함수를 작성는데, 적용해보니 문제없이 잘 동작했다.

<br>

2023.08.02  
페이드 효과를 코루틴으로 구현하는 것도 괜찮기는 하지만, 애니메이션을 사용하는 쪽이 코드 관리에 있어 더 간편하므로 웬만하면 유니티의 애니메이션으로 구현해주는 것이 더 좋다.
<!--

여담이지만, 이 기회로 코루틴을 처음 적용하면서 찾아보니 C# 구문의 `IEnumerator`의 표현 "Enumerator"는 가령 파이썬에서 쓰이는 "iterator"와 동일한 개념인 것도 알게 되었다.

-->