---
title:  "유니티 | 조이스틱 구현"

categories: [프로그래밍, 유니티]
tags: [유니티, Unity, 안드로이드, Android]

toc: true
toc_sticky: true
 
date: 2023-01-30
last_modified_at: 2023-04-13
---

<br>

유니티는 조이스틱 동작을 위한 `OnScreenStick` 클래스를 공식적으로 지원하므로 이것을 이용하는 것이 편리하다. `OnScreenStick` 클래스는 `Package Manager > Unity Registry`{: .filepath }에서 `Input System`을 설치 및 임포트하여 사용할 수 있으며, 조이스틱 역할을 할 이미지 UI 오브젝트에 해당 컴포넌트를 추가하여 사용할 수 있다. 풀 스크립트는 아래와 같이 76줄로 이루어져 있다.

<br>

```cs
#if PACKAGE_DOCS_GENERATION || UNITY_INPUT_SYSTEM_ENABLE_UI
using UnityEngine.EventSystems;
using UnityEngine.Serialization;
using UnityEngine.InputSystem.Layouts;

////TODO: custom icon for OnScreenStick component

namespace UnityEngine.InputSystem.OnScreen
{
    /// <summary>
    /// A stick control displayed on screen and moved around by touch or other pointer
    /// input.
    /// </summary>
    [AddComponentMenu("Input/On-Screen Stick")]
    [HelpURL(InputSystem.kDocUrl + "/manual/OnScreen.html#on-screen-sticks")]
    public class OnScreenStick : OnScreenControl, IPointerDownHandler, IPointerUpHandler, IDragHandler
    {
        public void OnPointerDown(PointerEventData eventData)
        {
            if (eventData == null)
                throw new System.ArgumentNullException(nameof(eventData));

            RectTransformUtility.ScreenPointToLocalPointInRectangle(transform.parent.GetComponentInParent<RectTransform>(), eventData.position, eventData.pressEventCamera, out m_PointerDownPos);
        }

        public void OnDrag(PointerEventData eventData)
        {
            if (eventData == null)
                throw new System.ArgumentNullException(nameof(eventData));

            RectTransformUtility.ScreenPointToLocalPointInRectangle(transform.parent.GetComponentInParent<RectTransform>(), eventData.position, eventData.pressEventCamera, out var position);
            var delta = position - m_PointerDownPos;

            delta = Vector2.ClampMagnitude(delta, movementRange);
            ((RectTransform)transform).anchoredPosition = m_StartPos + (Vector3)delta;

            var newPos = new Vector2(delta.x / movementRange, delta.y / movementRange);
            SendValueToControl(newPos);
        }

        public void OnPointerUp(PointerEventData eventData)
        {
            ((RectTransform)transform).anchoredPosition = m_StartPos;
            SendValueToControl(Vector2.zero);
        }

        private void Start()
        {
            m_StartPos = ((RectTransform)transform).anchoredPosition;
        }

        public float movementRange
        {
            get => m_MovementRange;
            set => m_MovementRange = value;
        }

        [FormerlySerializedAs("movementRange")]
        [SerializeField]
        private float m_MovementRange = 50;

        [InputControl(layout = "Vector2")]
        [SerializeField]
        private string m_ControlPath;

        private Vector3 m_StartPos;
        private Vector2 m_PointerDownPos;

        protected override string controlPathInternal
        {
            get => m_ControlPath;
            set => m_ControlPath = value;
        }
    }
}
#endif
```

<br>

다만 나는 조이스틱의 중심이 되는 오브젝트까지 포함해 하나의 프리팹으로 사용하고 싶어서, 조이스틱과 플레이어의 움직임을 동기화하기 위한 코드를 작성할 겸 새 스크립트를 작성했으며, 아래와 같이 플레이어 오브젝트와 좌표를 동기화하는 코드를 추가했다.

<br>

```cs
// movePlayer.cs

private float _moveSpeed = 0.1f;

void Update()
{
    distanceFromCenter = joystickPosition.anchoredPosition
                       - centerPosition.anchoredPosition
                       + new Vector2(transform.localScale.x / 2, transform.localScale.y / 2);

    player.transform.Translate(distanceFromCenter * Time.deltaTime * _moveSpeed);
  }
```

<br>

`anchoredPosition`은 화면의 좌측하단을 (0, 0), 우측상단을 (1, 1)로 가정하여 비율상으로 스크린상의 위치를 나타내기 위한 방법이다. 각 오브젝트의 좌표값 차를 통해 플레이어의 이동에 동기화하기 위한 벡터값을 구할 수 있으므로, 적절한 상수를 곱해 플레이어 이동을 구현할 수 있다.

<br>

---
# 참고
[유니티 스크립팅 API | Class OnScreenStick](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.OnScreen.OnScreenStick.html)