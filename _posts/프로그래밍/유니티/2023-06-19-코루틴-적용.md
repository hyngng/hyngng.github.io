---
title:  "유니티 | 코루틴으로 이미지 페이드아웃 효과 구현"

categories: [프로그래밍, 유니티]
tags: [프로그래밍, 유니티]

toc: true
toc_sticky: true

date: 2023-06-19
last_modified_at: 2023-06-19
---

<br>

막연하게 개념만 알고 있었던 코루틴을 실제 환경에서 사용해본건 처음인데, 전통적인 방식으로 이미지 페이드(Fade) 효과를 구현하다가 마주한 여러 오류를 해결하기 위해 복잡한 코드를 작성하는게 싫어서 대안삼아 도전하게 되었다.

<br>

```cs
private Coroutine currentFadeCoroutine;
private float _fadeSpeed;



private void Update() {
    if (currentFadeCoroutine != null) StopCoroutine(currentFadeCoroutine);
    currentFadeCoroutine = StartCoroutine(FadeImage(0f));
}



private IEnumerator FadeImage(float targetAlpha)
{
    Color startColor = Image.color;
    Color targetColor = new Color(startColor.r, startColor.g, startColor.b, targetAlpha);

    float t = 0f;
    while (t <= 1f)
    {
        t += Time.deltaTime * _fadeSpeed;
        Image.color = Color.Lerp(startColor, targetColor, t);
        yield return null;
    }
}
```

코드를 작성하면서 새로 배운 것이 있는데, 하나는 C# 구문에서 사용하는 `IEnumerator`의 표현 "Enumerator"는 iterator와 동일한 개념이라는 것이고, 다른 하나는 `yield return` 뒤에 코루틴이 작동되는 주기를 정의할 수 있다는 것(`null`은 기본적으로 하나의 프레임을 의미하며, `WaitForSeconds(n.0f)` 형식을 사용해 n초를 대기시킬 수 있다.), 다른 하나는 조금 지엽적인 것으로 유니티에서 이미지 색상값에 접근하는 방법이 매개변수가 실수 0f ~ 1f 사이로 정의된 `Color(r, g, b, a)`와 byte 0 ~ 255 사이로 정의된 `Color32(r, g, b, a)`가 있다는 것이다.  

`yield return`은 호출자(Caller)에게 데이터를 하나씩 리턴할 때 사용하는 키워드로서 Iterable Method를 작성할 때 사용한다는 것도 익숙치 않아 자주 까먹는데 기억해둬야 할 것 같다.

<br>

---
# 참고