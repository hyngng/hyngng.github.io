---
title:  "유니티 | 코루틴으로 이미지 페이드아웃 효과 구현"

categories: [프로그래밍, 유니티]
tags: [프로그래밍, 유니티]

toc: true
toc_sticky: true

date: 2023-06-19
last_modified_at: 2023-06-19
---

<br>

막연하게 개념만 알고 있었던 코루틴을 실제 환경에서 사용해본건 처음인데, 전통적인 방식으로 이미지 페이드(Fade) 효과를 구현하다가 마주한 여러 오류를 해결하기 위해 복잡한 코드를 작성하는게 싫어서 대안삼아 도전하게 되었다.

<br>

```cs
private Coroutine currentFadeCoroutine;
private float _fadeSpeed;



private void Update() {
    if (currentFadeCoroutine != null) StopCoroutine(currentFadeCoroutine);
    currentFadeCoroutine = StartCoroutine(FadeImage(0f));
}



private IEnumerator FadeImage(float targetAlpha)
{
    Color startColor = Image.color;
    Color targetColor = new Color(startColor.r, startColor.g, startColor.b, targetAlpha);

    float t = 0f;
    while (t <= 1f)
    {
        t += Time.deltaTime * _fadeSpeed;
        Image.color = Color.Lerp(startColor, targetColor, t);
        yield return null;
    }
}
```

이 경험으로 새로 배운 것이 있는데, 코루틴 관련해서는 C# 구문의 `IEnumerator`의 표현 "Enumerator"는 iterator와 동일한 개념이라는 것과 코루틴은 도중에 오류가 나면 작동하지 않는다는 것, `yield return`은 호출자(Caller)에게 데이터를 하나씩 리턴할 때 사용하는 키워드로서 Iterable Method를 작성할 때 사용한다는 것, 따라서 `yield return` 뒤에 코루틴이 작동되는 주기를 정의한다는 것이다. (예를 들어 1FPS를 의미하는`null` 대신 가령 `WaitForSeconds(n.0f)`의 형식을 사용해 n초를 대기시킬 수 있다)

지엽적으로는 유니티에서 이미지 색상값에 접근하는 방법이 매개변수가 실수 0f ~ 1f 사이로 정의된 `Color(r, g, b, a)`와 byte 0 ~ 255 사이로 정의된 `Color32(r, g, b, a)`가 있다는 것도 헷갈리지 않게 명심해두어야 할 것 같다.

<br>

---
# 참고