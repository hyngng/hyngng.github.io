---
title:  "유니티 | 코루틴 사용해 이미지 페이드아웃 효과 구현"

categories: [프로그래밍, 유니티]
tags: [프로그래밍, 유니티]

toc: true
toc_sticky: true

date: 2023-06-19
last_modified_at: 2023-06-19
---

<br>

페이드(Fade) 효과를 구현하기 위한 핵심 알고리즘 자체는 복잡하지 않지만, 전통적인 방식으로 `Image.color()` 함수의 투명도 매개변수에 적용하려다보니 값이 기준을 초과할 때 의도치 않은 사이클이 발생하는 문제가 있었다. 처음 작성했던 코드는 아래와 같다.

<br>

```cs
private Image _Image;



private void FadeOut()
{
    if (_Image.color.a - .1f > 0) transparency -= .1f;
    else if (_Image.color.a - .1f < 0) transparency -= 0;

    _Image.color = new Color32(1f, 1f, 1f, transparency);
}
```

<br>

기준값을 넘겼을 때 투명도(transparency)값이 초기화되는 것은 `Color32()`의 매개변수 형식이 `byte`이기 때문인 것으로 추측한다. 어찌저찌 해결할 수 있어 보이긴 했지만, 해결하기 위해 거쳐야 할 의미없는 복잡한 과정이 싫어 대안을 찾다보니 코루틴(Cooroutine)이 눈에 들어왔다. 코루틴은 막연하게 개념만 알고 있고 제대로 사용해본 적은 없었는데, 이번기회에 도전했다.

<br>

```cs
private Coroutine FadeCoroutine;
private float _fadeSpeed, _targetAlpha;



private void Update()
{
    if (FadeCoroutine != null) StopCoroutine(FadeCoroutine);
    FadeCoroutine = StartCoroutine(Fade(0f));
}



private IEnumerator Fade(float targetAlpha)
{
    Color startColor = Image.color;
    Color targetColor = new Color(startColor.r, startColor.g, startColor.b, targetAlpha);

    float t = 0f;
    while (t <= 1f)
    {
        t += Time.deltaTime * _fadeSpeed;
        Image.color = Color.Lerp(startColor, targetColor, t);
        yield return null;
    }
}
```

<br>

페이드아웃, 페이드인 효과 둘 다가 필요해 `Fade()` 함수 하나를 작성하고, 매개변수로 0f 또는 1f를 받아 각각 페이드아웃, 페이드인으로 동작하도록 구성했다. 적용해보니 잘 동작했다.

<br>

코루틴을 처음 적용하면서 새로 배운 것이 있는데, C# 구문의 `IEnumerator`의 표현 "Enumerator"는 iterator와 동일한 개념이라는 것과 코루틴은 도중에 오류가 나면 작동하지 않는다는 것, `yield return`은 호출자(Caller)에게 데이터를 하나씩 리턴할 때 사용하는 키워드로서 Iterable Method를 작성할 때 사용한다는 것, 따라서 `yield return` 뒤에 코루틴이 작동되는 주기를 정의한다는 것이다. (예를 들어 1FPS를 의미하는`null` 대신 가령 `WaitForSeconds(n.0f)`의 형식을 사용해 n초를 대기시킬 수 있다.)

<br>

지엽적으로는 유니티에서 이미지 색상값에 접근하는 방법이 매개변수가 실수 0f ~ 1f 사이로 정의된 `Color(r, g, b, a)`와 byte 0 ~ 255 사이로 정의된 `Color32(r, g, b, a)`가 있다는 것도 헷갈리지 않게 명심해두어야 할 것 같다.

<br>