---
title:  "선형 자료구조"

categories: [프로그래밍, 개념공부]
tags: [프로그래밍, 자료구조]

toc: true
toc_sticky: true
 
date: 2023-05-18
last_modified_at: 2023-05-18
---

<br>

**선형 구조**란 하나의 자료 앞뒤에 하나의 자료만이 존재할 수 있는 구조를 말한다. 반대로 **비선형 구조**의 경우 하나의 자료 앞뒤에 여러개의 데이터가 위치할 수 있는데, 이는 [별도의 글](https://kiw6024.github.io/posts/%EB%B9%84%EC%84%A0%ED%98%95-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/)로 정리한다.

<br>

# 선형 리스트

**Linear List** 또는 **Segmential List**로 불리는 **선형 리스트**는 직관적으로 가장 먼저 생각할 수 있는 순백한 자료구조로, 대표적으로 배열과 레코드가 있다.

<br>

```c
// C언어로 작성됨
int a[5] = {5, 6, 14, 27, 31};
```

N개의 데이터가 있는 상황에서 K번째 데이터를 추가하고 싶다면 N-K+1번의 데이터 이동이 필요하고, 반대로 K번째 데이터를 삭제하고 싶다면 N-K번의 데이터 이동이 필요하다. 예를 들어, 위 배열 `a[3]`에 '15'를 추가하고 싶다면 [5, 6, 14, __, 27, 31]처럼 5 - 4 + 1 = 2개를 이동시켜야 한다.

<br>

# 연결 리스트

**연결 리스트(Linked List)**는 선형 리스트에서 리스트단에서 데이터의 저장된 위치를 가진다는 개념이 더해진 자료구조이다.  
연결 리스트는 기억장소에 데이터가 연속적으로 저장되어 있지 않아도 포인터를 이용하여 처리가 가능하다는 이점이 있으나 포인터값을 할당함에 따른 기억장소의 낭비와, 탐색 시 데이터를 처음부터 탐색해야 한다는 단점이 있다.

<br>

세부적인 연결 리스트 유형은 아래와 같다.
- **다중 연결 리스트** : 포인터 여러개를 사용하는 연결 리스트이다.
- **이중 연결 리스트** : 리스트의 값 모두가 두 개의 링크부를 가짐. 그들이 서로 반대 방향으로 선행 수속 노드를 가리키게 한 연결 리스트이다.
- **환영 연결 리스트** : 단일 연결 리스트'의 마지막 링크에 리스트의 처음 노드를 가리키도록 구성한 연결 리스트이다.
- **이중 환영 연결 리스트** : 이중과 환영 연결 리스트의 개념을 모두 사용한 연결 리스트이다. 처음은 마지막, 마지막은 처음을 가리키는 구조로 구성되어 있다. 

<br>

# 스택

**스택(Stack)**은 원소의 추가와 삭제가 리스트 한쪽 끝에서 수행하는 **LIFO(Last-In, First-Out)** 자료구조를 말한다. 데이터 추가와 삭제가 이루어지는 부분을 **top**이라고 표현하고, 반대쪽 끝을 **bottom**이라고 표현한다.  
top은 데이터 입력시 top + 1을, 데이터 삭제시 top - 1을 수행하는데, 이를 알고리즘으로 나타내면 아래와 같다.

```c
// C언어로 작성됨

// 데이터 추가 알고리즘
if (top >= n) overflow;
stock[top] = data;
top += 1;

// 데이터 삭제 알고리즘
if (top == 0) underflow;
top -= 1;
stock[top] = NULL;
```

<br>

데이터의 입력동작을 **push**, 출력동작을 **pop**이라고 부른다. 주로 시스템단에서 함수를 호출할 때, 컴파일러단에서 **후위수식(PostFix)**을 계산할 때 사용한다.

<br>

# 큐

**큐(Queue)**는 원소의 추가와 삭제를 양쪽 끝에서 수행하는 **FIFO(First-In, First-Out)** 자료구조를 말한다. 스택과는 다르게 `tail`과 `head`라는 두 개 변수를 사용하여 입출력을 제어한다.  
tail과 head는 데이터 추가시 tail + 1을, 데이터 삭제시 head + 1을 수행하는데, 이를 알고리즘으로 나타내면 아래와 같다.

<br>

```c
// C언어로 작성됨

// 데이터 추가 알고리즘
if (tail >= n) overflow;
queue[tail] = data;
tail += 1;

// 데이터 삭제 알고리즘
if (head == 0 && tail == 0) underflow;
if ( head < tail) {
    queue[head] = NULL;
    head += 1;
    if (head == tail) {
    overflow,
    return
    }
}
```

큐는 운영체제 시스템에서 프로세스의 순차처리, **SpooL(Simultaneous Pheripheral Operaition On Line)** 처리 등에 사용하며, 세부적인 큐 유형은 아래와 같다.

- 이동 큐(Moving Queue)
- 원형 큐(Circular Queue)
- 다단계 큐(Multilevel Queue)
- 다중 큐(Multi Queue)