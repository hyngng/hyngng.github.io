---
title: "SOLID 원칙에 대한 개인적 주해"

categories: [프로그래밍, 고민거리]
tags: [프로그래밍, 고민거리]
start_with_ads: true

toc: true
toc_sticky: true

date: 2026-01-23 00:00:00 +0900
last_modified_at: 2025-01-23 00:00:00 +0900

mermaid: true
---

## **객체지향에 대한 단평**

- 사람이 이해하기 쉬운 구조로 작성하기 위한 방법론이지, 기계 친화적인 성능향상을 위한 방법론이 아님.
- 단적으로, 사람이 유지보수하기 위함임을 잘 염두해야 할듯.

## **SOLID 원칙**

SOLID 원칙은 단일 책임 원칙(SRP), 개방 폐쇄 원칙(OCP), 리스코프 치환 원칙(LSP), 인터페이스 분리 원칙(ISP), 의존성 역전 원칙(DIP) 등 다섯 가지 원칙을 모두 포함하는 용어입니다.

SOLID 원칙 자체는 접하고 적용해본지 2년정도가 다 되어가는데, 원칙의 개념은 이제 익숙하지만 그 적용은 아직 꽤 어렵다는 느낌이 듭니다. 그래도 정리해보니 SOLID한 개발철학은 추상적으로는 클래스간 의존도를 풀어헤치는 것, 그리고 좀 더 세부적으로는 다음의 두 가지 지향성으로 정리되는 것 같습니다.

## **분류를 명확히 해라**

단일 책임 원칙의 제안은 클래스의 역할을 명확히 정의하라는 것으로 꽤 명확합니다. 그 개념에 대한 이해는 어렵지 않지만, 실제로 클래스를 작성하다보면 어디까지가 단일책임이라고 할 수 있을지에 대한 고민이 생깁니다. 그런 상황을 잘 성찰해보고 지혜롭게 해결하라는 것 자체가 SOLID 원칙이 유도하고자 하는 맥락이겠지만, 원칙 자체는 이런 상황에 침묵합니다.

객체지향 구현을 위한 핵심개념 class가 '분류하다'라는 뜻의 classify의 명사형이라는 것을 고려하자면, 굳이 '단일 책임 원칙'이라고 부르지 않더라도 객체지향적인 설계 자체가 꽤 엄격한 분류와 정리를 요구합니다. 개인적 경험을 인용하자면, 이전에 [게임을 만들어 보면서](https://hyngng.github.io/posts/palette-second-devlog/) 플레이어 객체에 부착되는 한 개 클래스 `Player.cs`에 일부러 모든 책임을 부여하는 차력쇼를 해본 적이 있습니다. 의도는 명확했습니다. 하나는 "하나의 클래스에서 조금이라도 연관된 기능을 모두 모아 관리하면 코드를 여러 곳에 분산해서 작성할 필요가 없을 것이다"였고, 또 하나는 "최대한 긴 코드를 짜보고 싶다"였습니다.

`Player.cs` 하나에 처음에는 1000줄 넘게 작성했었고, 나중에 정리해보니 720줄 정도였습니다. 지금 글을 쓰면서 살펴보니 이 하나 클래스가 짊어지고 있는 책임은 이렇게 정리가 됩니다.

```mermaid
classDiagram
    class Player {
        -CubeData CubeData
        -GameObject WeaponObject
        -Vector3 PlayerVelocity
        -float MaxHP, HP
        -float PVATKR_Rate
        -int PlayerLevel
        -bool HasSpecialWeapon
        -bool isAlive
        -GameObject player, weaponPosition
        -Animator playerAnimator
        -Vector3 prePos, newPos
        -bool ifWeaponHeadsRight
        -bool isLoadingWeapon
        -float ratePVMSPD, ratePVHPRG
        -float playerMoveSpeed, defaultPlayerMoveSpeed
        -Animator RoundsAnimator
        -Animator HPAnimator
        -bool isOnProcessGettingCube
        -Vector3[] pointerDownPosition
        -Vector3 pointerUpPosition
        -Color startColor, targetColor
        -string initWeaponName
        -bool curntWeaponIsEmpty
        -GameObject _initWeapon
        -string cubeNameText, cubeInfoText
        -TextMeshPro cubeNameTextMeshPro
        -GameObject cubeInventory2, cubeName
        -SpriteRenderer backgroundImage
        -Coroutine currentOnPointCoroutineDefault
        -Vector3 targetSmallScale, targetBigScale
        -float fadeSpeed
        -Vector3 lastPosition
        -GameObject playerDiedParticleObject
        -ParticleSystem playerDiedParticle
        -int? cubeStat, cubeTempStat
        -int cubeBeingTriggeredCount
        -int cubeDataOrder
        -string cubeNameToGet
        -bool hasInstantiated
        -bool replaceWeaponToNew
        -bool hasSpawnedInitWeapon
        -AnimatorStateInfo weaponAnimationInfo
        -GameObject tempCubeUI, cubeToChange
        -List~GameObject~ targetCubeList

        +Awake() void
        +Start() void
        +Update() void
        +OnTriggerEnter2D(Collider2D) void
        +OnTriggerStay2D(Collider2D) void
        +OnTriggerExit2D(Collider2D) void
        -ifDied() void
        -playerMove() void
        -setPlayerProperty() void
        -getWeapon() void
        -getPVCubeEffect() void
        -getWPCubeEffect() void
        -setCubeInfo() void
        -getWeaponInfo() void
        -JoystickStatCoroutine() void
        -backgroundGlowByCoin() void
        -HpRegenerate() IEnumerator
        -OnPointerEffectDefault(float) IEnumerator
        -OnPointerEffectCube(float) IEnumerator
        -OnPointerEffect(float, float) void
        -StringInStrArray(string[], string) bool
        -FindIndexInStringArray(string[], string) int
        -FindIndexInGameObjectArray(GameObject[], string) int
    }
```

1. 입력에 따른 이동, 애니메이션, 효과음 제어
2. HP의 표시, 회복 및 사망 처리
3. 무기 교체, 무기별 특수효과
4. 8개 슬롯의 인벤토리 관리
5. 조이스틱 등의 UI

지금 살펴보니 좀 끔찍하네요. 굉장히 무겁고 불필요합니다. 특히 조이스틱 UI가 그렇습니다. 만약 지금 다시 같은 책임을 구현한다면, 이렇게 만들 것 같습니다.

그런데 개발을 주로 혼자 하다 보니, 

## **노자도덕경**

객체지향 설계는 무위자연의 경지에 도달하는 것.
- 춘추전국시대와 제자백가 등에 빗대어 도가사상에 대한 기초 설명(정말 간략히).
- 도가를 떠나 도(道)라는 한자가 갖는 의미에 대한 설명

- 객체지향은 인간이 가장 잘 이해할 수 있는 방법으로 (가장이라는 표현은 과장된 것이지만) 프로그래밍을 하는 것.
- ECS라는 설계법 등을 보면 정말 다름.
- 사실 프로그래밍이라는 것 자체가 인간이 하는 것이고, 또 할 수 있도록 설계된 것이지만은.

## **SRP: 단일 책임 원칙**

> 객체는 각각 하나만의 책임을 갖는다.

비슷하게 글쓰기에는 일문일사(一文一事) 원칙이 있습니다. 한 개의 문장에서는 한 가지의 주제만을 다루라는 내용입니다.

실존주의 철학에서 인간은 명료한 인식관을 갈구한다는 유명한 전제가 있습니다. 제 개인적인 경험으로 이것은 사실인 것 처럼 보입니다. 

의존성을 줄여야 한다는 내용입니다. 객체지향을 사용하는 목표중 하나인 모듈화에 대한 내용이기도 한데, 

## **DIP: 의존성 역전 원칙**

> 인터페이스의 구현체가 아닌, 인터페이스 그 자체에 의존하라.

이 부분은 꽤 재밌습니다. 굳이 기술적 용어를 들어 설명하지 않더라도 상식적으로 바른 내용이기 때문입니다.

제가 DIP 원칙을 읽고 구현해보면서 떠올렸던 것은 조직, 특히 회사가 스스로를 관리하는 방식입니다. 부서와 부서의 구성인원별로 업무분장이 나뉜 전형적인 회사 구조를 가정할 때, DIP 원칙에 따르면 회사는 사회적으로 먼저 합의된 개념, 즉 업무분장에 대해서만 의존해야지 그 업무를 수행하는 직원의 개인기나 기량에 의존해서는 안 된다고 설명할 수 있습니다.

회사의 나날은 고정된 것처럼 보이고 어제도 오늘도 내일도 그 직원이 그 자리에서 같은 업무를 수행할 것처럼 느껴집니다. 하지만 현실적으로 정기적 발령이나 급격한 인사이동, 퇴사, 극단적으로는 업무 담당자가 사망하는 등의 이유로 직원이 교체되는 일은 일어날 수밖에 없습니다. 이때 조직이 업무분장을 넘어 개개인의 역량에까지 의존하고 있었다면, 언젠가 그 사람이 부재하게 되었을 때 해당 업무에 대해 혼선이 빚어지게 됩니다.

이 관점에서 한 사람에게 합의된 범주를 넘어선 업무가 위임되는 상황을 막아야 이유는, 그것이 한 사람의 선의를 이용하는 비도덕적인 행위여서이기 이전에 조직이 와해되는 위험을 야기할 수 있기 때문입니다. 가령 조직에 요구되는 업무량이 늘어난 경우, 그때그때 개개인에게 업무를 위탁하는 대신 업무분장 등 책임이 분배되는 구조를 근본적으로 개선하는 식으로 해결되어야 합니다.

자리가 아닌 자리에 앉은 사람의 원맨쇼에 의지하는 경우가 있습니다. 그리고 그 경우는 생각보다 흔하게 찾아볼 수 있습니다. 이는 제 3자의 시선으로 보더라도 조직이 거만했다며, 그 위험을 사전에 탐지하지 못한 것은 조직의 책임이라는 거부감 섞인 비판으로 이어집니다.

이 감각을 기술적으로 번역하면 원문이 됩니다. '인터페이스를 상속받은 구현체가 아닌, 인터페이스 그 자체에 의존하라.' 제가 겪은 상황을 예시로 들자면 다음의 경우가 있었습니다.

```cs

```


- 버스 팩터 1

{% comment %}
직원은 지정된 업무분장을 실현하는 주체입니다.
{% endcomment %}