---
title: "C#에서 자주 사용하는 문법 총정리"

categories: [프로그래밍, 문법]
tags: [프로그래밍, 문법, 유니티, C#]
start_with_ads: true

toc: true
toc_sticky: true

date: 2024-10-14 00:00:00 +0900
last_modified_at: 2024-10-14 00:00:00 +0900

mermaid: true
---

- 또 다른 언어 사용하다보면 헷갈리고 까먹는게 생김. 그래서 원활한 개발을 위해 알 필요가 있는 기본 사항을 핵심 위주로 정리함

## **기본 네임스페이스**

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
```

### **System.Collections**

```mermaid
classDiagram
    class SystemCollections
    class SystemCollectionsGeneric

    class ArrayList
    class Hashtable
    class Stack
    class Queue
    class ListT
    class DictionaryT
    class QueueT
    class StackT

    SystemCollections <|-- ArrayList
    SystemCollections <|-- Hashtable
    SystemCollections <|-- Stack
    SystemCollections <|-- Queue

    SystemCollectionsGeneric <|-- ListT
    SystemCollectionsGeneric <|-- DictionaryT
    SystemCollectionsGeneric <|-- QueueT
    SystemCollectionsGeneric <|-- StackT
```

`System.Collections`와 `System.Collections.Generic`는 둘 다 자료구조 클래스를 정의하는 네임스페이스입니다. 각각 `ArrayList`, `Hashtable`, `Stack`, `Queue` 또는 `List<T>`, `Dictionary<T>`, `Queue<T>`, `Stack<T>` 등의 클래스가 정의되어 있으며, `System.Collections.Generic` 네임스페이스가 기존 `System.Collections`의 성능 문제를 개선한 네임스페이스이기 때문에 대부분은 이쪽을 사용하게 됩니다.

### **UnityEngine**

```mermaid
classDiagram
    class UnityEngine {
        <<namespace>>
    }

    class GameObject
    class Vector3
    class Physics
    class Material
    class AudioSource
    class Canvas
    class Animator
    class MonoBehaviour

    UnityEngine <|-- GameObject
    UnityEngine <|-- Vector3
    UnityEngine <|-- Physics
    UnityEngine <|-- Material
    UnityEngine <|-- AudioSource
    UnityEngine <|-- Canvas
    UnityEngine <|-- Animator
    UnityEngine <|-- MonoBehaviour
```

`GameObject`, `Vector3`, `Physics`, `AudioSource` 등 유니티에서 사용하는 개념이 정의되는 네임스페이스입니다. 비슷한 이름의 `UnityEditor` 네임스페이스가 있기 때문에 헷갈리지 않도록 주의할 필요가 있습니다.

## **클래스 선언 및 사용**

### **MonoBehaviour**

```cs
public class Player : MonoBehaviour
{
    /* ... */
}
```

MonoBehaviour는

### **상속**

- 상속 유형 여러가지.
    - static
    - 인스턴스 생성방법 여러가지
    - override 하는 법과 안 하는 법
    - protected, public 클래스

## **변수 선언 및 사용**

### **애트리뷰트**

```cs
[SerializeField]
[Header("this is a header")]
[Range(0, 1)]
private float speed;
```

| 속성(Attribute) | 설명 |
|---|---|
| SerializeField | `private`, `protected` 등 은닉된 변수를 인스펙터창에 표시한다 |
| Serializable | 별도의 클래스를 인스펙터창에 표시한다 |
| Header | 변수에 대한 간략한 설명으로 분류군을 표시한다 |
| HideInInspector | `public` 변수를 인스펙터에서 숨긴다 |
| RequireComponent | 해당 컴포넌트가 추가될 때 다른 컴포넌트도 함께 추가된다 |
| Range | `int`, `float` 변수를 특정 범위 내에서 인스펙터창으로 조절 가능하도록 변경한다 |
| Space | 한 줄의 간격을 추가한다 |
| CreateAssetMenu | `ScriptableObject` Asset을 생성할 때 메뉴 추가한다 |
| MenuItem | 해당 `static` 함수를 메뉴 항목에서 실행할 수 있도록 변경한다 |
| ContextMenu | 해당 `non-static` 함수 실행을 컴포넌트 톱니 메뉴에 추가한다 |
| AddComponentMenu | 인스펙터의 `AddComponent` 메뉴 항목으로 컴포넌트 추가 |
| ExecuteInEditMode| 플레이중이플레이 모드가 아니더라도 스크립트가 실행되도록 변경한다 |
| Multiline | 여러 줄의 `string` 변수를 입력받을 수 있도록 변경한다 |
| TextArea | 폭에 맞춰 자동으로 줄바꿈과 슬라이드바 표시한다 |
| Tooltip | 변수에 대한 설명을 표시한다 |

### **접근 제한자**

변수에는 아래의 3가지 접근 제한자를 부여할 수 있습니다.

- `public`
- `private`
- `protected`

### **배열과 리스트 선언**

```cs
/* 1차원 배열 */
private int[] intArray = new int[];

/* 2차원 배열 */
private int[,] matrix = {
    { 1, 2, 3 },
    { 4, 5, 6 }
};
```

- 배열의 크기는 `Array.Length()`로 가져옴

```cs
private List<int> = new List<int>();
```

- 리스트의 크기는 `List.Count()`로 가져옴

배열과 리스트의 선언방식이 다른 이유는 서로 다른 네임스페이스를 참조하기 때문입니다. 예를 들어 리스트는 `System.Collections.Generic`에서 가져오기 때문에 제네릭을 사용합니다.

### **Nullable 변수**

```cs
private int? number = null;
```

### **딕셔너리**

```cs
Dictionary<string, int> dictionary = new Dictionary<string, int>();
```

### **get set 프로퍼티**

```cs
private string name;
public string Name
{
    get { return name; }
    set { name = value; }
}
```

변수를 `private`로 선언해놓고 값을 외부 조건에 따라 변경하는 구조가 이상하게 느껴질 수 있지만, get set 프로퍼티를 사용하는 이유는 외부 클래스

## **함수 선언 및 사용**

```cs

```

### **람다 함수**

```cs
var specificNumbers = Array.FindAll(numbers, n => n % 2 == 0);
```

### **코루틴**

### **델리게이트**

## **조건문**

### **삼항 연산자**

```cs
condition ? value_if_true : value_if_false;
```

`if-else` 대신 사용하기 좋은 형식으로 압축성이 좋고 익숙해지고 나면 코드를 읽고 쓰는 속도도 빨라질 수 있으나, 삼항 연산자를 중첩해서 사용하는 경우 대개 가독성이 나빠지는 문제가 있으므로 그런 경우 코드 압축성을 포기하고 `switch`문을 사용하는 편이 나을 수 있습니다.

### **NULL 관련 연산자**

```cs
string result = value ?? "value not set";
```

- Null 병합 연산자

```cs
string? data = Database?.data;
```

- Null 조건부 연산자

## **반복문**

`for`, `while`문은 다른 언어와 비슷한 형태를 갖고 있어 헷갈릴 여지가 적지만 `foreach`는 존재감을 잊을 수 있음.

```cs
foreach (string item in itemList)
{
    Debug.Log(item);
}
```

파이썬의 `for`문과 매우 비슷하고 편하게 사용할 수 있습니다.